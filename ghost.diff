diff --git a/.gitignore b/.gitignore
index 082b7eb..e45b49b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -18,8 +18,11 @@ tools/changes/changes*
 tools/ramdisk-writer/ramdisk-writer*
 
 libc/libc.a
+libc/libc.so
 libapi/libghostapi.a
+libapi/libghostapi.so
 libuser/libghostuser.a
+libuser/libghostuser.so
 
 applications/**/*.bin
 applications/**/obj/*.o
diff --git a/applications/applications.sh b/applications/applications.sh
index 386dbf6..ec435f7 100644
--- a/applications/applications.sh
+++ b/applications/applications.sh
@@ -52,7 +52,7 @@ target_compile() {
 
 target_link() {
 	echo "linking:"
-	$CROSS_CXX -o $ARTIFACT_LOCAL $OBJ/*.o -lghostuser $LDFLAGS
+	$CROSS_CXX -o $ARTIFACT_LOCAL $OBJ/*.o $LDFLAGS
 	list $ARTIFACT_LOCAL
 }
 	
diff --git a/applications/cocorun/build.sh b/applications/cocorun/build.sh
index 4050799..35a6f43 100644
--- a/applications/cocorun/build.sh
+++ b/applications/cocorun/build.sh
@@ -11,7 +11,7 @@ SRC=src
 OBJ=obj
 ARTIFACT_NAME=cocorun.bin
 CFLAGS="-std=c++11 -I$SRC"
-LDFLAGS="-lcoconut -Wl,-Bdynamic"
+LDFLAGS=""
 
 # Include application build tasks
 . "../applications.sh"
diff --git a/applications/cocorun/src/cocorun.cpp b/applications/cocorun/src/cocorun.cpp
index afef735..4781ff2 100644
--- a/applications/cocorun/src/cocorun.cpp
+++ b/applications/cocorun/src/cocorun.cpp
@@ -21,10 +21,13 @@
 #include <ghost.h>
 #include "../libcoconut/inc/coconut.h"
 
+__thread int bla;
+
 /**
  *
  */
 int main(int argc, char** argv)
 {
-	coconutThrow();
+	g_log("Hello world");
+	bla = 1;
 }
diff --git a/applications/testprogram/src/tester.cpp b/applications/testprogram/src/tester.cpp
index 24106f6..6372306 100644
--- a/applications/testprogram/src/tester.cpp
+++ b/applications/testprogram/src/tester.cpp
@@ -35,5 +35,10 @@ int main(int argc, char** argv)
 
 	klog("Test suite finished: %i successful, %i failed", result.successful, result.failed);
 
+	klog("Calling shared library test...");
+	g_spawn("/applications/cocorun.bin", "", "/", G_SECURITY_LEVEL_APPLICATION);
+
+	g_sleep(3000);
+	klog("Restarting myself");
 	g_spawn("/applications/tester.bin", "-respawned", "/", G_SECURITY_LEVEL_APPLICATION);
 }
diff --git a/kernel/inc/ghost/elf32.h b/kernel/inc/ghost/elf32.h
index 464363d..e5e2e8b 100644
--- a/kernel/inc/ghost/elf32.h
+++ b/kernel/inc/ghost/elf32.h
@@ -121,16 +121,73 @@ typedef struct {
 #define PF_MASKPROC		0xF0000000
 
 typedef struct {
-	elf32_word p_type; // Type of the segment
-	elf32_off p_offset; // Offset of the segment in the binary file
-	elf32_addr p_vaddr; // Virtual address
-	elf32_addr p_paddr; // Not relevant for System V
-	elf32_word p_filesz; // Size of the segment in the binary file
-	elf32_word p_memsz; // Size of the segment in memory
-	elf32_word p_flags; // Segment flags
-	elf32_word p_align; // Alignment information
+	elf32_word	p_type;		// Type of the segment
+	elf32_off	p_offset;	// Offset of the segment in the binary file
+	elf32_addr	p_vaddr;	// Virtual address
+	elf32_addr	p_paddr;	// Not relevant for System V
+	elf32_word	p_filesz;	// Size of the segment in the binary file
+	elf32_word	p_memsz;	// Size of the segment in memory
+	elf32_word	p_flags;	// Segment flags
+	elf32_word	p_align;	// Alignment information
 } __attribute__((packed)) elf32_phdr;
 
+/**
+ * ELF dynamic section structure
+ */
+typedef struct {
+	elf32_sword d_tag; // Controls interpretation of d_un, see DT_*
+	union {
+		elf32_word d_val;
+		elf32_addr d_ptr;
+	} d_un;
+} __attribute__((packed)) elf32_dyn;
+
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH	15
+#define DT_SYMBOLIC	16
+#define DT_REL		17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+#define DT_LOPROC	0x70000000
+#define DT_HIPROC	0x7fffffff
+
+
+/**
+ * ELF symbol table
+ */
+typedef struct {
+	elf32_word	st_name;	// Index to symbol string name
+	elf32_addr	st_value;	// Value of associated symbol
+	elf32_word	st_size;	// Size of the symbol
+	uint8_t		st_info;	// Type and binding attributes
+	uint8_t		st_other;	// Undefined
+	elf32_half	st_shndx;	// Section header table index
+} elf32_sym;
+
+#define STB_LOCAL	0
+#define STB_GLOBAL	1
+#define STB_WEAK	2
+#define STB_LOPROC	13
+#define STB_HIPROC	15
+
 __END_C
 
 #endif
diff --git a/kernel/inc/ghost/system.h b/kernel/inc/ghost/system.h
index e4b83db..f788c37 100644
--- a/kernel/inc/ghost/system.h
+++ b/kernel/inc/ghost/system.h
@@ -44,6 +44,8 @@ typedef uint8_t g_spawn_status;
 #define G_SPAWN_STATUS_MEMORY_ERROR						((g_spawn_status) 2)
 #define G_SPAWN_STATUS_FORMAT_ERROR						((g_spawn_status) 3)
 #define G_SPAWN_STATUS_TASKING_ERROR					((g_spawn_status) 4)
+#define G_SPAWN_STATUS_DEPENDENCY_ERROR					((g_spawn_status) 5)
+#define G_SPAWN_STATUS_DEPENDENCY_DUPLICATE				((g_spawn_status) 6)
 
 typedef uint8_t g_spawn_validation_details;
 #define G_SPAWN_VALIDATION_SUCCESSFUL				((g_spawn_validation_details) 0)
diff --git a/kernel/include/kernel/tasking/elf32_loader.hpp b/kernel/include/kernel/tasking/elf32_loader.hpp
index c4805a5..48cab7a 100644
--- a/kernel/include/kernel/tasking/elf32_loader.hpp
+++ b/kernel/include/kernel/tasking/elf32_loader.hpp
@@ -25,36 +25,140 @@
 #include "kernel/filesystem/ramdisk.hpp"
 #include "kernel/memory/memory.hpp"
 #include "kernel/tasking/tasking.hpp"
+#include "kernel/utils/hashmap.hpp"
+#include "kernel/utils/hashmap_string.hpp"
+#include "shared/utils/string.hpp"
 
+struct g_elf_object;
+
+struct g_elf_dependency {
+	char* name;
+	g_elf_dependency* next;
+};
 
 /**
- * Spawns an ELF32 binary to a new process.
+ * Structure of an ELF32 object in memory.
  */
-g_spawn_status elf32Spawn(g_task* caller, g_fd file, g_security_level securityLevel, g_task** outTask = 0, g_spawn_validation_details* outValidationDetails = 0);
+struct g_elf_object {
+	g_elf_object* parent;
+	char* name;
+
+	elf32_ehdr header;
+	g_elf_dependency* dependencies;
+
+    g_virtual_address startAddress;
+    g_virtual_address endAddress;
+	g_virtual_address baseAddress;
+
+	struct
+	{
+		g_virtual_address location;
+		g_virtual_address copysize;
+		g_virtual_address totalsize;
+		g_virtual_address alignment;
+	} tlsMaster;
+
+	/* Only relevant for an executable object */
+	g_hashmap<const char*, g_virtual_address>* symbols;
+	g_hashmap<const char*, g_elf_object*>* loadedDependencies;
+
+	/* In-address-space memory pointers */
+	elf32_dyn* dynamicSection;
+
+	char* stringTable;
+	elf32_word stringTableSize;
+	elf32_sym* symbolTable;
+	elf32_word symbolTableSize;
+	elf32_word* symbolHashTable;
+
+	void (*init)();
+	void (*fini)();
+};
 
 /**
- * Reads the ELF header from the file.
+ * Loads an ELF binary and creates a process for it.
+ * 
+ * @param caller
+ * 		task starting this executable
+ * @param securityLevel	
+ * 		security level to apply
+ * @param outTask
+ * 		out parameter for created task
+ * @param outValidationDetails
+ * 		out parameter for validation status
+ * @return the spawn status
  */
-g_spawn_validation_details elf32ReadAndValidateHeader(g_task* caller, g_fd file, elf32_ehdr* headerBuffer);
+g_spawn_status elf32LoadExecutable(g_task* caller, g_fd file, g_security_level securityLevel,
+	g_task** outTask = 0, g_spawn_validation_details* outValidationDetails = 0);
 
 /**
- * Validates the given ELF header.
+ * Loads a shared library.
+ * 
+ * @param caller
+ * 		task performing the loading
+ * @param parentObject
+ * 		parent ELF object
+ * @param name
+ * 		name of the shared library
+ * @param baseAddress
+ * 		address where to start loading the library
+ * @param outNextBase
+ * 		out parameter for next address after this library and all of its dependencies
+ */
+g_spawn_status elf32LoadLibrary(g_task* caller, g_elf_object* parentObject, const char* name,
+	g_virtual_address baseAddress, g_address_range_pool* rangeAllocator,
+	g_virtual_address* outNextBase, g_elf_object** outObject);
+
+/**
+ * Loads an object to the current address space.
  */
-g_spawn_validation_details elf32Validate(elf32_ehdr* header);
+g_spawn_status elf32LoadObject(g_task* caller, g_elf_object* parentObject, const char* name,
+	g_fd file, g_virtual_address baseAddress, g_address_range_pool* rangeAllocator,
+	g_virtual_address* outNextBase, g_elf_object** outObject, g_spawn_validation_details* outValidationDetails = 0);
 
 /**
- * Loads a binary to the address space of the target process. Temporarily switches to the address space of the target process.
+ * Searches for a library file and opens it.
  */
-g_spawn_status elf32LoadBinaryToProcessSpace(g_task* caller, g_fd file, elf32_ehdr* header, g_process* targetProcess, g_security_level securityLevel);
+g_fd elf32OpenLibrary(g_task* caller, const char* name);
+
+/**
+ * Loads all dependencies of an object.
+ */
+g_virtual_address elf32LoadDependencies(g_task* caller, g_elf_object* parentObject, g_address_range_pool* rangeAllocator);
 
 /**
  * Loads a load segment to memory, must be called while within the target process address space.
  */
-g_spawn_status elf32LoadLoadSegment(g_task* caller, g_fd fd, elf32_phdr* phdr, g_process* targetProcess);
+g_spawn_status elf32LoadLoadSegment(g_task* caller, g_fd fd, elf32_phdr* phdr, g_virtual_address baseAddress, g_elf_object* object);
 
 /**
  * Loads the TLS master to memory, must be called while within the target process address space.
  */
-g_spawn_status elf32LoadTlsMasterCopy(g_task* caller, g_fd file, elf32_phdr* header, g_process* targetProcess);
+g_spawn_status elf32LoadTlsMasterCopy(g_task* caller, g_fd file, elf32_phdr* header, g_elf_object* object, g_address_range_pool* rangeAllocator);
+
+/**
+ * Reads the ELF header from the file.
+ */
+g_spawn_validation_details elf32ReadAndValidateHeader(g_task* caller, g_fd file, elf32_ehdr* headerBuffer, bool executable);
+
+/**
+ * Validates the given ELF header.
+ */
+g_spawn_validation_details elf32Validate(elf32_ehdr* header, bool executable);
+
+/**
+ * Allocates an empty ELF object structure.
+ */
+g_elf_object* elf32AllocateObject();
+
+/**
+ * Reads information provided in the ELF object.
+ */
+void elf32InspectObject(g_elf_object* elfObject);
+
+/**
+ * Utility function to read data to memory.
+ */
+bool elf32ReadToMemory(g_task* caller, g_fd fd, size_t offset, uint8_t* buffer, uint64_t len);
 
 #endif
diff --git a/kernel/src/kernel/calls/syscall_tasking.cpp b/kernel/src/kernel/calls/syscall_tasking.cpp
index 8aa202d..46d8c78 100644
--- a/kernel/src/kernel/calls/syscall_tasking.cpp
+++ b/kernel/src/kernel/calls/syscall_tasking.cpp
@@ -157,7 +157,7 @@ void syscallSpawn(g_task* task, g_syscall_spawn* data)
 	if(open == G_FS_OPEN_SUCCESSFUL)
 	{
 		g_task* targetTask;
-		data->spawnStatus = elf32Spawn(task, fd, G_SECURITY_LEVEL_APPLICATION, &targetTask, &data->validationDetails);
+		data->spawnStatus = elf32LoadExecutable(task, fd, G_SECURITY_LEVEL_APPLICATION, &targetTask, &data->validationDetails);
 		if(data->spawnStatus == G_SPAWN_STATUS_SUCCESSFUL)
 		{
 			data->pid = targetTask->process->id;
diff --git a/kernel/src/kernel/kernel.cpp b/kernel/src/kernel/kernel.cpp
index c552da6..4979f9f 100644
--- a/kernel/src/kernel/kernel.cpp
+++ b/kernel/src/kernel/kernel.cpp
@@ -117,14 +117,14 @@ void kernelRunApplicationCore()
 void kernelInitializationThread()
 {
 	g_task* currentTask = taskingGetCurrentTask();
-	logInfo("%! initializing system services in spawner %i", "kernel", currentTask->id);
+	logInfo("%! initializing system services in task %i", "kernel", currentTask->id);
 
 	g_fd fd;
-	g_fs_open_status open = filesystemOpen("/applications/tester.bin", G_FILE_FLAG_MODE_READ, currentTask, &fd);
+	g_fs_open_status open = filesystemOpen("/applications/cocorun.bin", G_FILE_FLAG_MODE_READ, currentTask, &fd);
 	if(open == G_FS_OPEN_SUCCESSFUL)
 	{
 		g_task* testerTask;
-		g_spawn_status spawn = elf32Spawn(currentTask, fd, G_SECURITY_LEVEL_APPLICATION, &testerTask);
+		g_spawn_status spawn = elf32LoadExecutable(currentTask, fd, G_SECURITY_LEVEL_APPLICATION, &testerTask);
 		if(spawn == G_SPAWN_STATUS_SUCCESSFUL)
 			logInfo("%! test suite spawned successfully to task %i", "kernel", testerTask->id);
 		else
diff --git a/kernel/src/kernel/logger/kernel_logger.cpp b/kernel/src/kernel/logger/kernel_logger.cpp
index 537c0c0..fd46670 100644
--- a/kernel/src/kernel/logger/kernel_logger.cpp
+++ b/kernel/src/kernel/logger/kernel_logger.cpp
@@ -45,7 +45,7 @@ void kernelLoggerPrintHeader(g_setup_information* info)
 	consoleVideoSetColor(0x0F);
 	logInfo(" Version %i.%i.%i", G_VERSION_MAJOR, G_VERSION_MINOR, G_VERSION_PATCH);
 	logInfo("");
-	logInfo("  Copyright (C) 2019, Max Schluessel <lokoxe@gmail.com>");
+	logInfo("  Copyright (C) 2020, Max Schluessel <lokoxe@gmail.com>");
 	logInfo("");
 	logInfo("%! initializing core services", "kernel");
 
diff --git a/kernel/src/kernel/system/interrupts/ioapic.cpp b/kernel/src/kernel/system/interrupts/ioapic.cpp
index 521fbb1..804c1ea 100644
--- a/kernel/src/kernel/system/interrupts/ioapic.cpp
+++ b/kernel/src/kernel/system/interrupts/ioapic.cpp
@@ -67,9 +67,8 @@ void ioapicInitialize(g_ioapic* io)
 
 	// Get version
 	uint32_t versionValue = ioapicRead(io, IOAPIC_VER);
-	uint32_t version = versionValue & 0xFF;
 	io->redirectEntryCount = (versionValue >> 16) & 0xFF;
-	logDebug("%! id %i: version %i, redirect entries: %i", "ioapic", io->id, version, io->redirectEntryCount);
+	logDebug("%! id %i: version %i, redirect entries: %i", "ioapic", io->id, versionValue & 0xFF, io->redirectEntryCount);
 }
 
 void ioapicCreateMapping(g_ioapic* io)
diff --git a/kernel/src/kernel/tasking/elf32_loader.cpp b/kernel/src/kernel/tasking/elf32_loader.cpp
index e13ed4e..d890713 100644
--- a/kernel/src/kernel/tasking/elf32_loader.cpp
+++ b/kernel/src/kernel/tasking/elf32_loader.cpp
@@ -26,277 +26,511 @@
 
 #define MAXIMUM_LOAD_PAGES_AT_ONCE 0x10
 
-g_spawn_status elf32Spawn(g_task* caller, g_fd fd, g_security_level securityLevel, g_task** outTask, g_spawn_validation_details* outValidationDetails)
+#define ELF_LOADER_LOG_INFO	1
+#if ELF_LOADER_LOG_INFO
+#undef logDebug
+#undef logDebugn
+#define logDebug(msg...) logInfo(msg)
+#define logDebugn(msg...) logInfon(msg)
+#endif
+
+g_spawn_status elf32LoadExecutable(g_task* caller, g_fd fd, g_security_level securityLevel, g_task** outTask, g_spawn_validation_details* outValidationDetails)
 {
-	elf32_ehdr header;
-	g_spawn_validation_details status = elf32ReadAndValidateHeader(caller, fd, &header);
-	if(outValidationDetails)
-		*outValidationDetails = status;
-	if(status != G_SPAWN_VALIDATION_SUCCESSFUL)
-	{
-		return G_SPAWN_STATUS_FORMAT_ERROR;
-	}
-
-	// Create a new process & load binary
+	/* Create process and load binary */
 	g_process* targetProcess = taskingCreateProcess();
-	g_spawn_status spawnStatus = elf32LoadBinaryToProcessSpace(caller, fd, &header, targetProcess, securityLevel);
+	g_physical_address returnDirectory = taskingTemporarySwitchToSpace(targetProcess->pageDirectory);
+	g_elf_object* executableObject;
+	g_virtual_address executableEnd;
+	g_spawn_status spawnStatus = elf32LoadObject(caller, 0, "main", fd, 0, targetProcess->virtualRangePool, &executableEnd, &executableObject, outValidationDetails);
+	taskingTemporarySwitchBack(returnDirectory);
 	if(spawnStatus != G_SPAWN_STATUS_SUCCESSFUL)
 	{
-		logInfo("%! failed to load binary to current address space", "spawner");
+		logInfo("%! failed to load binary to current address space", "elf");
 		return spawnStatus;
 	}
 
-	// Create main task AFTER loading binary so it can copy it's TLS
-	g_task* targetTask = taskingCreateThread(header.e_entry, targetProcess, securityLevel);
-	if(targetTask == 0)
+	/* Update process */	
+	targetProcess->image.start = executableObject->startAddress;
+	targetProcess->image.end = executableEnd;
+
+	#warning TODO tls segments of shared libraries are not taken into account...
+	targetProcess->tlsMaster.alignment = executableObject->tlsMaster.alignment;
+	targetProcess->tlsMaster.copysize = executableObject->tlsMaster.copysize;
+	targetProcess->tlsMaster.location = executableObject->tlsMaster.location;
+	targetProcess->tlsMaster.totalsize = executableObject->tlsMaster.totalsize;
+	logInfo("%! process loaded to %h - %h", "elf", targetProcess->image.start, targetProcess->image.end);
+
+	/* Create main thread */
+	g_task* thread = taskingCreateThread(executableObject->header.e_entry, targetProcess, securityLevel);
+	if(thread == 0)
 	{
-		logInfo("%! failed to create main thread to spawn ELF binary from ramdisk", "elf32");
+		logInfo("%! failed to create main thread to spawn ELF binary from ramdisk", "elf");
 		return G_SPAWN_STATUS_TASKING_ERROR;
 	}
+	taskingAssign(taskingGetLocal(), thread);
 
-	// Add to scheduling list
-	taskingAssign(taskingGetLocal(), targetTask);
-
-	// Set out parameter
-	if(outTask)
-		*outTask = targetTask;
-	logDebug("%! loading binary: %s to task: %i", "elf32", entry->name, targetTask->id);
+	*outTask = thread;
 	return G_SPAWN_STATUS_SUCCESSFUL;
 }
 
-bool elf32ReadAllBytes(g_task* caller, g_fd fd, size_t offset, uint8_t* buffer, uint64_t len)
+g_spawn_status elf32LoadLibrary(g_task* caller, g_elf_object* parentObject, const char* name, g_virtual_address baseAddress,
+	g_address_range_pool* rangeAllocator, g_virtual_address* outNextBase, g_elf_object** outObject)
 {
-	int64_t seeked;
-	g_fs_seek_status seekStatus = filesystemSeek(caller, fd, G_FS_SEEK_SET, offset, &seeked);
-	if(seekStatus != G_FS_SEEK_SUCCESSFUL)
-		return false;
-	if(seeked != offset)
-		logInfo("%! tried to seek in file to position %i but only got to %i", "spawner", (uint32_t )offset, (uint32_t )seeked);
-
-	uint64_t remain = len;
-	while(remain)
+	/* Check if dependency is already loaded */
+	g_elf_object* executableObject = parentObject;
+	while(executableObject->parent)
 	{
-		int64_t read;
-		g_fs_read_status readStatus = filesystemRead(caller, fd, &buffer[len - remain], remain, &read);
-		if(readStatus != G_FS_READ_SUCCESSFUL)
-		{
-			logInfo("%! failed to read binary from fd %i", "spawner", fd);
-			return false;
-		}
-		remain -= read;
+		executableObject = executableObject->parent;
+	}
+	if(hashmapGet(executableObject->loadedDependencies, name, (g_elf_object*) 0))
+	{
+		return G_SPAWN_STATUS_DEPENDENCY_DUPLICATE;
 	}
-	return true;
-}
 
-g_spawn_validation_details elf32ReadAndValidateHeader(g_task* caller, g_fd file, elf32_ehdr* headerBuffer)
-{
-	if(!elf32ReadAllBytes(caller, file, 0, (uint8_t*) headerBuffer, sizeof(elf32_ehdr)))
+	/* Open and load library */
+	g_fd fd = elf32OpenLibrary(caller, name);
+	if(fd == -1)
 	{
-		logInfo("%! failed to spawn file %i due to io error", "spawner", file);
-		return G_SPAWN_VALIDATION_ELF32_IO_ERROR;
+		return G_SPAWN_STATUS_DEPENDENCY_ERROR;
 	}
-	return elf32Validate(headerBuffer);
+	g_spawn_status status = elf32LoadObject(caller, parentObject, name, fd, baseAddress, rangeAllocator, outNextBase, outObject);
+	filesystemClose(caller->process->id, fd, true);
+	return status;
 }
 
-g_spawn_validation_details elf32Validate(elf32_ehdr* header)
+g_spawn_status elf32LoadObject(g_task* caller, g_elf_object* parentObject, const char* name, g_fd file, g_virtual_address baseAddress,
+	g_address_range_pool* rangeAllocator, g_virtual_address* outNextBase, g_elf_object** outObject, g_spawn_validation_details* outValidationDetails)
 {
-	// Valid ELF header
-	if(/**/(header->e_ident[EI_MAG0] != ELFMAG0) || // 0x7F
-			(header->e_ident[EI_MAG1] != ELFMAG1) ||	  // E
-			(header->e_ident[EI_MAG2] != ELFMAG2) ||	  // L
-			(header->e_ident[EI_MAG3] != ELFMAG3))		  // F
-	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_ELF;
-	}
+	logDebug("%! loading object '%s' to %h", "elf", name, baseAddress);
+	bool isExecutable = (parentObject == 0);
+	g_spawn_status status = G_SPAWN_STATUS_SUCCESSFUL;
 
-	// Must be executable
-	if(header->e_type != ET_EXEC)
+	g_elf_object* object = elf32AllocateObject();
+	object->name = stringDuplicate(name);
+	object->parent = parentObject;
+	object->baseAddress = baseAddress;
+	if(isExecutable)
 	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_EXECUTABLE;
+		object->loadedDependencies = hashmapCreateString<g_elf_object*>(128);
+		object->symbols = hashmapCreateString<g_virtual_address>(128);
 	}
-
-	// Must be i386 architecture compatible
-	if(header->e_machine != EM_386)
+	*outObject = object;
+	
+	/* Read and validate the ELF header */
+	g_spawn_validation_details validationStatus = elf32ReadAndValidateHeader(caller, file, &object->header, isExecutable);
+	if(outValidationDetails)
 	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_I386;
+		*outValidationDetails = validationStatus;
 	}
-
-	// Must be 32 bit
-	if(header->e_ident[EI_CLASS] != ELFCLASS32)
+	if(validationStatus != G_SPAWN_VALIDATION_SUCCESSFUL)
 	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_32BIT;
+		logInfo("%! validation failed when loading object %s with status %i", "elf", name, validationStatus);
+		return G_SPAWN_STATUS_FORMAT_ERROR;
 	}
 
-	// Must be little endian
-	if(header->e_ident[EI_DATA] != ELFDATA2LSB)
+	/* Load all program headers */
+	for(uint32_t i = 0; i < object->header.e_phnum; i++)
 	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_LITTLE_ENDIAN;
+		uint32_t phdrOffset = object->header.e_phoff + object->header.e_phentsize * i;
+		uint32_t phdrLength = sizeof(elf32_phdr);
+		uint8_t phdrBuffer[phdrLength];
+
+		if(!elf32ReadToMemory(caller, file, phdrOffset, phdrBuffer, phdrLength))
+		{
+			logInfo("%! failed to read segment header from file %i", "elf", file);
+			status = G_SPAWN_STATUS_IO_ERROR;
+			break;
+		}
+
+		elf32_phdr* phdr = (elf32_phdr*) phdrBuffer;
+		if(phdr->p_type == PT_LOAD)
+		{
+			status = elf32LoadLoadSegment(caller, file, phdr, baseAddress, object);
+			if(status != G_SPAWN_STATUS_SUCCESSFUL)
+			{
+				logInfo("%! unable to load PT_LOAD segment from file", "elf");
+				break;
+			}
+
+		} else if(phdr->p_type == PT_TLS)
+		{
+			status = elf32LoadTlsMasterCopy(caller, file, phdr, object, rangeAllocator);
+			if(status != G_SPAWN_STATUS_SUCCESSFUL)
+			{
+				logInfo("%! unable to load PT_TLS segment from file", "elf");
+				break;
+			}
+
+		} else if(phdr->p_type == PT_DYNAMIC)
+		{ 
+			object->dynamicSection = (elf32_dyn*) (baseAddress + phdr->p_vaddr);
+			logDebug("%!   object has dynamic information %h", "elf", object->dynamicSection);
+		}
 	}
 
-	// Must comply to current ELF standard
-	if(header->e_version != EV_CURRENT)
-	{
-		return G_SPAWN_VALIDATION_ELF32_NOT_STANDARD_ELF;
+	/* Do analyzation and linking */
+	if(status == G_SPAWN_STATUS_SUCCESSFUL) {
+		elf32InspectObject(object);
+		*outNextBase = elf32LoadDependencies(caller, object, rangeAllocator);
 	}
 
-	// All fine
-	return G_SPAWN_VALIDATION_SUCCESSFUL;
+	return status;
 }
 
-g_spawn_status elf32LoadBinaryToProcessSpace(g_task* caller, g_fd file, elf32_ehdr* header, g_process* targetProcess, g_security_level securityLevel)
+g_virtual_address elf32LoadDependencies(g_task* caller, g_elf_object* object, g_address_range_pool* rangeAllocator)
 {
-	g_physical_address returnDirectory = taskingTemporarySwitchToSpace(targetProcess->pageDirectory);
-	g_spawn_status status = G_SPAWN_STATUS_SUCCESSFUL;
+	g_virtual_address nextBase = object->endAddress;
 
-	for(uint32_t i = 0; i < header->e_phnum; i++)
+	g_elf_dependency* dependency = object->dependencies;
+	while(dependency)
 	{
-		uint32_t phdrOffset = header->e_phoff + header->e_phentsize * i;
-		uint32_t phdrLength = sizeof(elf32_phdr);
-		uint8_t phdrBuffer[phdrLength];
+		g_elf_object* dependencyObject;
+		g_spawn_status status = elf32LoadLibrary(caller, object, dependency->name, nextBase, rangeAllocator, &nextBase, &dependencyObject);
 
-		if(!elf32ReadAllBytes(caller, file, phdrOffset, phdrBuffer, phdrLength))
+		if(status == G_SPAWN_STATUS_SUCCESSFUL)
 		{
-			logInfo("%! failed to read segment header from file %i", "spawner", file);
-			status = G_SPAWN_STATUS_IO_ERROR;
-			break;
+			g_elf_object* executableObject = object;
+			while(executableObject->parent)
+			{
+				executableObject = executableObject->parent;
+			}
+			hashmapPut<const char*, g_elf_object*>(executableObject->loadedDependencies, dependency->name, dependencyObject);
+			logDebug("%!  -> successfully loaded dependency", "elf");
+
+		} else if(status == G_SPAWN_STATUS_DEPENDENCY_DUPLICATE)
+		{
+			logInfo("%!   -> duplicate dependency ignored: %s -> %s", "elf", object->name, dependency->name);
+
 		} else
 		{
-			elf32_phdr* phdr = (elf32_phdr*) phdrBuffer;
+			status = G_SPAWN_STATUS_DEPENDENCY_ERROR;
+			logInfo("%!   -> failed to load dependency %s", "elf", dependency->name);
+			break;
+		}
+		dependency = dependency->next;
+	}
 
-			if(phdr->p_type == PT_LOAD)
-			{
-				status = elf32LoadLoadSegment(caller, file, phdr, targetProcess);
-				if(status != G_SPAWN_STATUS_SUCCESSFUL)
-				{
-					logInfo("%! unable to load PT_LOAD segment from file", "spawner");
+	return nextBase;
+}
+
+void elf32InspectObject(g_elf_object* object) {
+
+	if(object->dynamicSection) {
+		/* Find tables that we need */
+		elf32_dyn* it = object->dynamicSection;
+		while(it->d_tag) {
+			switch(it->d_tag) {
+				case DT_STRTAB:
+					object->stringTable = (char*) (object->baseAddress + it->d_un.d_ptr);
 					break;
-				}
-			} else if(phdr->p_type == PT_TLS)
+				case DT_STRSZ:
+					object->stringTableSize = it->d_un.d_val;
+					break;
+				case DT_HASH:
+					object->symbolHashTable = (elf32_word*) (object->baseAddress + it->d_un.d_ptr);
+					/*  The number of symbol table entries should equal nchain; so symbol table indexes also select chain table entries. */
+					object->symbolTableSize = object->symbolHashTable[1]; 
+					break;
+				case DT_SYMTAB:
+					object->symbolTable = (elf32_sym*) (object->baseAddress + it->d_un.d_ptr);
+					break;
+				case DT_INIT:
+					object->init = (void(*)()) (object->baseAddress + it->d_un.d_ptr);
+					break;
+				case DT_FINI:
+					object->fini = (void(*)()) (object->baseAddress + it->d_un.d_ptr);
+					break;
+			}
+			it++;
+		}
+
+		/* Read dependencies */
+		object->dependencies = 0;
+		it = object->dynamicSection;
+		while(it->d_tag) {
+			if(it->d_tag == DT_NEEDED) {
+				g_elf_dependency* dep = (g_elf_dependency*) heapAllocate(sizeof(g_elf_dependency));
+				dep->name = stringDuplicate(object->stringTable + it->d_un.d_val);
+				dep->next = object->dependencies;
+				object->dependencies = dep;
+			}
+			it++;
+		}
+
+		/* Put symbols into executables symbol table */
+		if(object->symbolTable) {
+			g_elf_object* executableObject = object;
+			while(executableObject->parent)
+			{
+				executableObject = executableObject->parent;
+			}
+
+			uint32_t pos = 0;
+			elf32_sym* it = object->symbolTable;
+			while(pos < object->symbolTableSize)
 			{
-				status = elf32LoadTlsMasterCopy(caller, file, phdr, targetProcess);
-				if(status != G_SPAWN_STATUS_SUCCESSFUL)
+				const char* symbol = (const char*) (object->stringTable + it->st_name);
+				if(it->st_shndx && hashmapGet<const char*, g_virtual_address>(executableObject->symbols, symbol, 0) == 0)
 				{
-					logInfo("%! unable to load PT_TLS segment from file", "spawner");
-					break;
+					hashmapPut<const char*, g_virtual_address>(executableObject->symbols, symbol, object->baseAddress + it->st_value);
+					logDebug("%!      found symbol %s with value %h", "elf", symbol, object->baseAddress + it->st_value);
 				}
+
+				it++;
+				pos++;
 			}
 		}
 	}
-
-	taskingTemporarySwitchBack(returnDirectory);
-	return status;
 }
 
-g_spawn_status elf32LoadLoadSegment(g_task* caller, g_fd file, elf32_phdr* phdr, g_process* targetProcess)
+g_spawn_status elf32LoadLoadSegment(g_task* caller, g_fd file, elf32_phdr* phdr, g_virtual_address baseAddress, g_elf_object* object)
 {
-	uint32_t imageStart = phdr->p_vaddr & ~0xFFF;
-	uint32_t imageEnd = ((phdr->p_vaddr + phdr->p_memsz) + 0x1000) & ~0xFFF;
+	/* Calculate addresses where segment is loaded */
+	g_virtual_address loadBase = baseAddress + phdr->p_vaddr;
+	g_virtual_address loadEnd = loadBase + phdr->p_filesz;
+	g_virtual_address memoryStart = loadBase & ~G_PAGE_ALIGN_MASK;
+	g_virtual_address memoryEnd = ((loadBase + phdr->p_memsz) & ~G_PAGE_ALIGN_MASK) + G_PAGE_SIZE;
+
+	if(object->startAddress == 0 || memoryStart < object->startAddress) {
+		object->startAddress = memoryStart;
+	}
+	if(memoryEnd > object->endAddress) {
+		object->endAddress = memoryEnd;
+	}
 
-	uint32_t pagesTotal = (imageEnd - imageStart) / 0x1000;
+	uint32_t pagesTotal = (memoryEnd - memoryStart) / G_PAGE_SIZE;
 	uint32_t pagesLoaded = 0;
 
-	uint32_t offsetInFile = 0;
-
+	uint32_t loadPosition = loadBase;
+	uint32_t readOffset = phdr->p_offset;
 	while(pagesLoaded < pagesTotal)
 	{
-		uint32_t startVirt = imageStart + pagesLoaded * G_PAGE_SIZE;
+		/* Allocate memory */
+		uint32_t areaPages = (pagesTotal - pagesLoaded);
+		if(areaPages > MAXIMUM_LOAD_PAGES_AT_ONCE)
+			areaPages = MAXIMUM_LOAD_PAGES_AT_ONCE;
 
-		// Map next chunk of memory
-		uint32_t chunkPages = (pagesTotal - pagesLoaded);
-		if(chunkPages > MAXIMUM_LOAD_PAGES_AT_ONCE)
-		{
-			chunkPages = MAXIMUM_LOAD_PAGES_AT_ONCE;
-		}
-		for(uint32_t i = 0; i < chunkPages; i++)
+		g_virtual_address areaStart = memoryStart + pagesLoaded * G_PAGE_SIZE;
+		g_virtual_address areaEnd = (areaStart + areaPages * G_PAGE_SIZE);
+
+		for(uint32_t i = 0; i < areaPages; i++)
 		{
 			g_physical_address page = bitmapPageAllocatorAllocate(&memoryPhysicalAllocator);
 			pageReferenceTrackerIncrement(page);
-			pagingMapPage(startVirt + i * G_PAGE_SIZE, page, DEFAULT_USER_TABLE_FLAGS, DEFAULT_USER_PAGE_FLAGS);
+			pagingMapPage(areaStart + i * G_PAGE_SIZE, page, DEFAULT_USER_TABLE_FLAGS, DEFAULT_USER_PAGE_FLAGS);
 		}
-		uint8_t* area = (uint8_t*) startVirt;
 
-		// Is there anything left to copy?
-		uint32_t virtualFileEnd = phdr->p_vaddr + phdr->p_filesz;
-		uint32_t bytesToCopy = 0;
-
-		if(startVirt < virtualFileEnd)
+		if(loadPosition < loadEnd)
 		{
-			// Check if file ends in this area
-			if((virtualFileEnd >= startVirt) && (virtualFileEnd < (startVirt + chunkPages * G_PAGE_SIZE)))
+			uint32_t copyBytes = 0;
+			if(loadEnd < areaEnd) {
+				copyBytes = loadEnd - loadPosition;
+			} else {
+				copyBytes = areaEnd - loadPosition;
+			}
+
+			/* Zero area before content in memory (if we are at the start) */
+			uint32_t sizeBefore = loadPosition - areaStart;
+			if(sizeBefore > 0)
 			{
-				bytesToCopy = virtualFileEnd - startVirt;
-			} else
+				memorySetBytes((void*) areaStart, 0, sizeBefore);
+
+				logDebug("%!   [%h-%h] zero %h bytes before code", "elf", areaStart, areaStart + sizeBefore, sizeBefore);
+			}
+
+			/* Copy data to memory */
+			if(!elf32ReadToMemory(caller, file, readOffset, (uint8_t*) loadPosition, copyBytes))
 			{
-				bytesToCopy = chunkPages * G_PAGE_SIZE;
+				logInfo("%! unable to read data for PT_LOAD header", "elf");
+				return G_SPAWN_STATUS_IO_ERROR;
 			}
-		}
+			logDebug("%!   [%h-%h] read %h bytes from file %h", "elf", loadPosition, loadPosition + copyBytes, copyBytes, readOffset);
 
-		// Read file to memory
-		if(!elf32ReadAllBytes(caller, file, phdr->p_offset + offsetInFile, area, bytesToCopy))
-		{
-			logInfo("%! unable to read LOAD segment", "spawner");
-			return G_SPAWN_STATUS_IO_ERROR;
-		}
+			/* Zero memory after content in memory */
+			uint32_t loadEnd = loadPosition + copyBytes;
+			uint32_t sizeAfter = areaEnd - loadEnd;
+			if(sizeAfter > 0)
+			{
+				memorySetBytes((void*) loadEnd, 0, sizeAfter);
 
-		// Zero area before content in memory (if we are at the start)
-		if(imageStart == startVirt && phdr->p_vaddr - startVirt > 0)
-		{
-			memorySetBytes(area, 0, startVirt);
-		}
+				logDebug("%!   [%h-%h] zero %h bytes after code", "elf", loadEnd, loadEnd + sizeAfter, sizeAfter);
+			}
 
-		// Zero memory after content in memory
-		if(bytesToCopy < chunkPages * G_PAGE_SIZE)
-		{
-			uint32_t endZeroAreaStart = ((uint32_t) area) + bytesToCopy;
-			uint32_t endZeroAreaLength = (chunkPages * G_PAGE_SIZE) - bytesToCopy;
-			memorySetBytes((void*) endZeroAreaStart, 0, endZeroAreaLength);
+			loadPosition += copyBytes;
+			readOffset += copyBytes;
+
+		} else {
+			/* Zero area without any content */
+			uint32_t areaSize = areaPages * G_PAGE_SIZE;
+			memorySetBytes((void*) areaStart, 0, areaSize);
+			loadPosition += areaSize;
+
+			logDebug("%!   [%h-%h] zero %h bytes of blank", "elf", areaStart, areaEnd, areaSize);
 		}
 
-		pagesLoaded += chunkPages;
-		offsetInFile += bytesToCopy;
+		pagesLoaded += areaPages;
 	}
 
-	targetProcess->image.start = imageStart;
-	targetProcess->image.end = imageEnd;
 	return G_SPAWN_STATUS_SUCCESSFUL;
 }
 
-g_spawn_status elf32LoadTlsMasterCopy(g_task* caller, g_fd file, elf32_phdr* phdr, g_process* targetProcess)
+g_spawn_status elf32LoadTlsMasterCopy(g_task* caller, g_fd file, elf32_phdr* phdr, g_elf_object* object, g_address_range_pool* rangeAllocator)
 {
 	uint32_t bytesToCopy = phdr->p_filesz;
 	uint32_t bytesToZero = phdr->p_memsz;
+	logDebug("%!   loading TLS master copy %h", "elf", phdr->p_vaddr);
 
+	/* Read TLS content to a buffer */
 	uint8_t* tlsContentBuffer = (uint8_t*) heapAllocate(bytesToCopy);
+	if(!elf32ReadToMemory(caller, file, phdr->p_offset, (uint8_t*) tlsContentBuffer, bytesToCopy))
+	{
+		logInfo("%! unable to read TLS segment from file", "elf");
+		heapFree(tlsContentBuffer);
+		return G_SPAWN_STATUS_IO_ERROR;
+
+	}
 
-	g_spawn_status status;
-	if(!elf32ReadAllBytes(caller, file, phdr->p_offset, (uint8_t*) tlsContentBuffer, bytesToCopy))
+	/* Allocate memory */
+	uint32_t requiredPages = G_PAGE_ALIGN_UP(bytesToZero) / G_PAGE_SIZE;
+	g_virtual_address tlsStart = addressRangePoolAllocate(rangeAllocator, requiredPages, G_PROC_VIRTUAL_RANGE_FLAG_PHYSICAL_OWNER);
+	for(uint32_t i = 0; i < requiredPages; i++)
 	{
-		status = G_SPAWN_STATUS_IO_ERROR;
-		logInfo("%! unable to read TLS segment from file", "spawner");
-	} else
+		g_physical_address page = bitmapPageAllocatorAllocate(&memoryPhysicalAllocator);
+		pagingMapPage(tlsStart + i * G_PAGE_SIZE, page, DEFAULT_USER_TABLE_FLAGS, DEFAULT_USER_PAGE_FLAGS);
+		pageReferenceTrackerIncrement(page);
+	}
+
+	memorySetBytes((uint8_t*) tlsStart, 0, bytesToZero);
+	memoryCopy((uint8_t*) tlsStart, tlsContentBuffer, bytesToCopy);
+
+	logDebug("%!   initialized TLS with size of %i pages", "elf", requiredPages);
+
+	/* Write object information */
+	object->tlsMaster.location = tlsStart;
+	object->tlsMaster.alignment = phdr->p_align;
+	object->tlsMaster.copysize = phdr->p_filesz;
+	object->tlsMaster.totalsize = phdr->p_memsz;
+
+	heapFree(tlsContentBuffer);
+	return G_SPAWN_STATUS_SUCCESSFUL;
+}
+
+bool elf32ReadToMemory(g_task* caller, g_fd fd, size_t offset, uint8_t* buffer, uint64_t len)
+{
+	int64_t seeked;
+	g_fs_seek_status seekStatus = filesystemSeek(caller, fd, G_FS_SEEK_SET, offset, &seeked);
+	if(seekStatus != G_FS_SEEK_SUCCESSFUL)
 	{
-		uint32_t requiredPages = G_PAGE_ALIGN_UP(bytesToZero) / G_PAGE_SIZE;
-		g_virtual_address tlsStart = addressRangePoolAllocate(targetProcess->virtualRangePool, requiredPages, G_PROC_VIRTUAL_RANGE_FLAG_PHYSICAL_OWNER);
+		logInfo("%! failed to seek to %i binary from fd %i", "elf", offset, fd);
+		return false;
+	}
+	if(seeked != offset)
+	{
+		logInfo("%! tried to seek in file to position %i but only got to %i", "elf", (uint32_t )offset, (uint32_t )seeked);
+	}
 
-		for(uint32_t i = 0; i < requiredPages; i++)
+	uint64_t remain = len;
+	while(remain)
+	{
+		int64_t read;
+		g_fs_read_status readStatus = filesystemRead(caller, fd, &buffer[len - remain], remain, &read);
+		if(readStatus != G_FS_READ_SUCCESSFUL)
 		{
-			g_physical_address page = bitmapPageAllocatorAllocate(&memoryPhysicalAllocator);
-			pagingMapPage(tlsStart + i * G_PAGE_SIZE, page, DEFAULT_USER_TABLE_FLAGS, DEFAULT_USER_PAGE_FLAGS);
-			pageReferenceTrackerIncrement(page);
+			logInfo("%! failed to read binary from fd %i", "elf", fd);
+			return false;
 		}
+		remain -= read;
+	}
+	return true;
+}
 
-		memorySetBytes((uint8_t*) tlsStart, 0, bytesToZero);
-		memoryCopy((uint8_t*) tlsStart, tlsContentBuffer, bytesToCopy);
+g_spawn_validation_details elf32ReadAndValidateHeader(g_task* caller, g_fd file, elf32_ehdr* headerBuffer, bool executable)
+{
+	if(!elf32ReadToMemory(caller, file, 0, (uint8_t*) headerBuffer, sizeof(elf32_ehdr)))
+	{
+		logInfo("%! failed to spawn file %i due to io error", "elf", file);
+		return G_SPAWN_VALIDATION_ELF32_IO_ERROR;
+	}
+	return elf32Validate(headerBuffer, executable);
+}
 
-		logDebug("%! initialized TLS with size of %i pages for target process %i", "spawner", requiredPages, targetProcess->id);
+g_spawn_validation_details elf32Validate(elf32_ehdr* header, bool executable)
+{
+	if(/* */(header->e_ident[EI_MAG0] != ELFMAG0) ||      // 0x7F
+			(header->e_ident[EI_MAG1] != ELFMAG1) ||	  // E
+			(header->e_ident[EI_MAG2] != ELFMAG2) ||	  // L
+			(header->e_ident[EI_MAG3] != ELFMAG3))		  // F
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_ELF;
+	}
 
-		targetProcess->tlsMaster.location = tlsStart;
-		targetProcess->tlsMaster.alignment = phdr->p_align;
-		targetProcess->tlsMaster.copysize = phdr->p_filesz;
-		targetProcess->tlsMaster.totalsize = phdr->p_memsz;
-		status = G_SPAWN_STATUS_SUCCESSFUL;
+	/* Check executable flag */
+	if(executable && header->e_type != ET_EXEC)
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_EXECUTABLE;
 	}
 
-	heapFree(tlsContentBuffer);
-	return status;
+	/* Must be i386 architecture compatible */
+	if(header->e_machine != EM_386)
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_I386;
+	}
+
+	/* Must be 32 bit */
+	if(header->e_ident[EI_CLASS] != ELFCLASS32)
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_32BIT;
+	}
+
+	/* Must be little endian */
+	if(header->e_ident[EI_DATA] != ELFDATA2LSB)
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_LITTLE_ENDIAN;
+	}
+
+	/* Must comply to current ELF standard */
+	if(header->e_version != EV_CURRENT)
+	{
+		return G_SPAWN_VALIDATION_ELF32_NOT_STANDARD_ELF;
+	}
+
+	return G_SPAWN_VALIDATION_SUCCESSFUL;
 }
+
+g_elf_object* elf32AllocateObject()
+{
+	g_elf_object* object = (g_elf_object*) heapAllocate(sizeof(g_elf_object));
+	memorySetBytes((void*) object, 0, sizeof(g_elf_object));
+	return object;
+}
+
+g_fd elf32OpenLibrary(g_task* caller, const char* name)
+{
+	const char* prefix = "/system/lib/";
+	char* absolutePath = (char*) heapAllocate(stringLength(prefix) + stringLength(name) + 1);
+	stringConcat(prefix, name, absolutePath);
+
+	g_fs_node* file;
+	bool foundAllButLast;
+	g_fs_node* lastFoundParent;
+	const char* filenameStart;
+
+	g_fs_open_status findStatus = filesystemFind(0, absolutePath, &file, &foundAllButLast, &lastFoundParent, &filenameStart);
+	if(findStatus != G_FS_OPEN_SUCCESSFUL) {
+		logInfo("%! unable to resolve dependency %s", "elf", name);
+		heapFree(absolutePath);
+		return -1;
+	}
+
+	g_fd fd;
+	g_fs_open_status openStatus = filesystemOpen(file, G_FILE_FLAG_MODE_BINARY | G_FILE_FLAG_MODE_READ, caller, &fd);
+	if(openStatus != G_FS_OPEN_SUCCESSFUL) {
+		logInfo("%! unable to open dependency %s", "elf", absolutePath);
+		heapFree(absolutePath);
+		return -1;
+	}
+
+	heapFree(absolutePath);
+	return fd;
+}
+
diff --git a/kernel/src/kernel/tasking/tasking.cpp b/kernel/src/kernel/tasking/tasking.cpp
index e934e03..2ed7770 100644
--- a/kernel/src/kernel/tasking/tasking.cpp
+++ b/kernel/src/kernel/tasking/tasking.cpp
@@ -291,10 +291,10 @@ g_process* taskingCreateProcess()
 
 	mutexInitialize(&process->lock);
 
-	process->tlsMaster.location = 0;
+	process->tlsMaster.alignment = 0;
 	process->tlsMaster.copysize = 0;
+	process->tlsMaster.location = 0;
 	process->tlsMaster.totalsize = 0;
-	process->tlsMaster.alignment = 0;
 
 	process->pageDirectory = taskingMemoryCreatePageDirectory();
 
@@ -326,7 +326,7 @@ void taskingPrepareThreadLocalStorage(g_task* thread)
 	g_process* process = thread->process;
 	if(process->tlsMaster.location == 0)
 	{
-		logInfo("%! failed to copy tls master for task %i, not available in process", "tls", thread->id);
+		logDebug("%! while loading task %i: process %i does not have a tls", "tls", thread->id, process->id);
 		return;
 	}
 
diff --git a/libapi/build.sh b/libapi/build.sh
index 0d6151e..1d60d50 100755
--- a/libapi/build.sh
+++ b/libapi/build.sh
@@ -17,8 +17,12 @@ with INC_KERNEL				"../kernel/inc"
 with ARTIFACT_NAME			"libghostapi.a"
 with ARTIFACT_LOCAL			"$ARTIFACT_NAME"
 with ARTIFACT_TARGET		"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME"
+with ARTIFACT_NAME_SHARED	"libghostapi.so"
+with ARTIFACT_LOCAL_SHARED	"$ARTIFACT_NAME_SHARED"
+with ARTIFACT_TARGET_SHARED	"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME_SHARED"
 
-with CFLAGS					"-std=c++11 -I$INC -I$INC_KERNEL"
+with CFLAGS					"-std=c++11 -fpic -I$INC -I$INC_KERNEL"
+with LDFLAGS				"-shared"
 
 
 echo "target: $TARGET"
@@ -31,6 +35,7 @@ mkdir -p $OBJ
 target_clean() {
 	echo "cleaning:"
 	rm $ARTIFACT_LOCAL
+	rm $ARTIFACT_LOCAL_SHARED
 	cleanDirectory $OBJ
 	changes --clear
 }
@@ -65,11 +70,14 @@ target_compile() {
 target_archive() {
 	echo "archiving:"
 	$CROSS_AR -r $ARTIFACT_LOCAL $OBJ/*.o
+	$CROSS_CC $LDFLAGS -o $ARTIFACT_LOCAL_SHARED $OBJ/*.o
 }
 	
 target_clean_target() {
 	echo "removing $ARTIFACT_TARGET"
 	rm $ARTIFACT_TARGET 2&> /dev/null
+	echo "removing $ARTIFACT_TARGET_SHARED"
+	rm $ARTIFACT_TARGET_SHARED 2&> /dev/null
 }
 
 target_install_headers() {
@@ -84,8 +92,9 @@ target_install() {
 	target_clean_target
 	target_install_headers
 	
-	echo "installing artifact"
+	echo "installing artifacts"
 	cp $ARTIFACT_LOCAL $ARTIFACT_TARGET
+	cp $ARTIFACT_LOCAL_SHARED $ARTIFACT_TARGET_SHARED
 }
 
 
diff --git a/libc/build.sh b/libc/build.sh
index 9ebf05f..e4c5d8b 100755
--- a/libc/build.sh
+++ b/libc/build.sh
@@ -17,11 +17,15 @@ with INC_API				"../libapi/inc"
 with INC_KERNEL				"../kernel/inc"
 
 with ARTIFACT_NAME			"libc.a"
-ARTIFACT_LOCAL="$ARTIFACT_NAME"
-ARTIFACT_TARGET="$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME"
+with ARTIFACT_LOCAL			"$ARTIFACT_NAME"
+with ARTIFACT_TARGET		"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME"
+with ARTIFACT_NAME_SHARED	"libc.so"
+with ARTIFACT_LOCAL_SHARED	"$ARTIFACT_NAME_SHARED"
+with ARTIFACT_TARGET_SHARED	"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME_SHARED"
 
-with CFLAGS					"-std=c11 -I$INC -I$INC_API -I$INC_KERNEL -I$SRC/musl -Wno-narrowing"
-with CCFLAGS				"-std=c11 -I$INC -I$INC_API -I$INC_KERNEL"
+with CFLAGS					"-std=c11 -fpic -I$INC -I$INC_API -I$INC_KERNEL -I$SRC/musl -Wno-narrowing"
+with CCFLAGS				"-std=c11 -fpic -I$INC -I$INC_API -I$INC_KERNEL"
+with LDFLAGS				"-shared"
 
 with CRT_SRC				"crt"
 with CRT_OBJ				"crtobj"
@@ -41,6 +45,7 @@ mkdir -p $CRT_OBJ
 target_clean() {
 	echo "cleaning:"
 	rm $ARTIFACT_LOCAL
+	rm $ARTIFACT_LOCAL_SHARED
 	cleanDirectory $OBJ
 	cleanDirectory $CRT_OBJ
 	changes --clear
@@ -115,6 +120,7 @@ target_assemble_crts() {
 target_archive() {
 	echo "archiving:"
 	$CROSS_AR -r $ARTIFACT_LOCAL $OBJ/*.o
+	$CROSS_CC $LDFLAGS -o $ARTIFACT_LOCAL_SHARED $OBJ/*.o
 }
 
 target_install_headers() {
@@ -134,8 +140,9 @@ target_install() {
 	echo "creating lib installation directory"
 	mkdir -p $SYSROOT_SYSTEM_LIB
 	
-	echo "installing artifact"
+	echo "installing artifacts"
 	cp $ARTIFACT_LOCAL $ARTIFACT_TARGET
+	cp $ARTIFACT_LOCAL_SHARED $ARTIFACT_TARGET_SHARED
 	
 	echo "installing crts"
 	for name in ${CRT_NAMES[@]}; do
@@ -147,7 +154,7 @@ target_install() {
 	$CROSS_AR -r $SYSROOT_SYSTEM_LIB/libm.a
 	
 	# c'mon
-	chmod -R 0777 $SYSROOT
+	sudo chmod -R 0777 $SYSROOT
 }
 
 
diff --git a/libc/src/musl/README b/libc/src/musl/README
new file mode 100644
index 0000000..76e7a65
--- /dev/null
+++ b/libc/src/musl/README
@@ -0,0 +1,7 @@
+This folder contains the libm sources taken from the musl libc.
+
+The architecture folders are currently not really taken into account, everything
+that is found in all subfolders is simply built.
+
+When copying those files from musl, I removed the C files for which an
+architecture-specific implementation is present.
diff --git a/libc/src/musl/fenv/___tls_get_addr.c b/libc/src/musl/fenv/___tls_get_addr.c
new file mode 100644
index 0000000..78ad0a1
--- /dev/null
+++ b/libc/src/musl/fenv/___tls_get_addr.c
@@ -0,0 +1,7 @@
+#warning What should this do?
+
+int ___tls_get_addr() {
+    klog("Not implemented: ___tls_get_addr");
+    for(;;);
+    return 0;
+}
diff --git a/libc/src/musl/fenv/fesetround.c b/libc/src/musl/fenv/fesetround.c
new file mode 100644
index 0000000..0290716
--- /dev/null
+++ b/libc/src/musl/fenv/fesetround.c
@@ -0,0 +1,23 @@
+#include <fenv.h>
+
+/* __fesetround wrapper for arch independent argument check */
+
+int __fesetround(int);
+
+int fesetround(int r)
+{
+	if (r & ~(
+		FE_TONEAREST
+#ifdef FE_DOWNWARD
+		|FE_DOWNWARD
+#endif
+#ifdef FE_UPWARD
+		|FE_UPWARD
+#endif
+#ifdef FE_TOWARDZERO
+		|FE_TOWARDZERO
+#endif
+		))
+		return -1;
+	return __fesetround(r);
+}
diff --git a/libc/src/musl/fenv/hwcap.c b/libc/src/musl/fenv/hwcap.c
new file mode 100644
index 0000000..11b98ae
--- /dev/null
+++ b/libc/src/musl/fenv/hwcap.c
@@ -0,0 +1,7 @@
+#warning What should this do?
+
+int __hwcap() {
+    klog("Not implemented: __hwcap");
+    for(;;);
+    return 0;
+}
diff --git a/libc/src/musl/fenv/i386/fenv.s b/libc/src/musl/fenv/i386/fenv.s
new file mode 100644
index 0000000..08585d4
--- /dev/null
+++ b/libc/src/musl/fenv/i386/fenv.s
@@ -0,0 +1,163 @@
+.hidden __hwcap
+
+.global feclearexcept
+.type feclearexcept,@function
+feclearexcept:	
+	mov 4(%esp),%ecx
+	and $0x3f,%ecx
+	fnstsw %ax
+		# consider sse fenv as well if the cpu has XMM capability
+	call 1f
+1:	addl $__hwcap-1b,(%esp)
+	pop %edx
+	testl $0x02000000,(%edx)
+	jz 2f
+		# maintain exceptions in the sse mxcsr, clear x87 exceptions
+	test %eax,%ecx
+	jz 1f
+	fnclex
+1:	push %edx
+	stmxcsr (%esp)
+	pop %edx
+	and $0x3f,%eax
+	or %eax,%edx
+	test %edx,%ecx
+	jz 1f
+	not %ecx
+	and %ecx,%edx
+	push %edx
+	ldmxcsr (%esp)
+	pop %edx
+1:	xor %eax,%eax
+	ret
+		# only do the expensive x87 fenv load/store when needed
+2:	test %eax,%ecx
+	jz 1b
+	not %ecx
+	and %ecx,%eax
+	test $0x3f,%eax
+	jz 1f
+	fnclex
+	jmp 1b
+1:	sub $32,%esp
+	fnstenv (%esp)
+	mov %al,4(%esp)
+	fldenv (%esp)
+	add $32,%esp
+	xor %eax,%eax
+	ret
+
+.global feraiseexcept
+.type feraiseexcept,@function
+feraiseexcept:	
+	mov 4(%esp),%eax
+	and $0x3f,%eax
+	sub $32,%esp
+	fnstenv (%esp)
+	or %al,4(%esp)
+	fldenv (%esp)
+	add $32,%esp
+	xor %eax,%eax
+	ret
+
+.global __fesetround
+.type __fesetround,@function
+__fesetround:
+	mov 4(%esp),%ecx
+	push %eax
+	xor %eax,%eax
+	fnstcw (%esp)
+	andb $0xf3,1(%esp)
+	or %ch,1(%esp)
+	fldcw (%esp)
+		# consider sse fenv as well if the cpu has XMM capability
+	call 1f
+1:	addl $__hwcap-1b,(%esp)
+	pop %edx
+	testl $0x02000000,(%edx)
+	jz 1f
+	stmxcsr (%esp)
+	shl $3,%ch
+	andb $0x9f,1(%esp)
+	or %ch,1(%esp)
+	ldmxcsr (%esp)
+1:	pop %ecx
+	ret
+
+.global fegetround
+.type fegetround,@function
+fegetround:
+	push %eax
+	fnstcw (%esp)
+	pop %eax
+	and $0xc00,%eax
+	ret
+
+.global fegetenv
+.type fegetenv,@function
+fegetenv:
+	mov 4(%esp),%ecx
+	xor %eax,%eax
+	fnstenv (%ecx)
+		# consider sse fenv as well if the cpu has XMM capability
+	call 1f
+1:	addl $__hwcap-1b,(%esp)
+	pop %edx
+	testl $0x02000000,(%edx)
+	jz 1f
+	push %eax
+	stmxcsr (%esp)
+	pop %edx
+	and $0x3f,%edx
+	or %edx,4(%ecx)
+1:	ret
+
+.global fesetenv
+.type fesetenv,@function
+fesetenv:
+	mov 4(%esp),%ecx
+	xor %eax,%eax
+	inc %ecx
+	jz 1f
+	fldenv -1(%ecx)
+	movl -1(%ecx),%ecx
+	jmp 2f
+1:	push %eax
+	push %eax
+	push %eax
+	push %eax
+	pushl $0xffff
+	push %eax
+	pushl $0x37f
+	fldenv (%esp)
+	add $28,%esp
+		# consider sse fenv as well if the cpu has XMM capability
+2:	call 1f
+1:	addl $__hwcap-1b,(%esp)
+	pop %edx
+	testl $0x02000000,(%edx)
+	jz 1f
+		# mxcsr := same rounding mode, cleared exceptions, default mask
+	and $0xc00,%ecx
+	shl $3,%ecx
+	or $0x1f80,%ecx
+	mov %ecx,4(%esp)
+	ldmxcsr 4(%esp)
+1:	ret
+
+.global fetestexcept
+.type fetestexcept,@function
+fetestexcept:
+	mov 4(%esp),%ecx
+	and $0x3f,%ecx
+	fnstsw %ax
+		# consider sse fenv as well if the cpu has XMM capability
+	call 1f
+1:	addl $__hwcap-1b,(%esp)
+	pop %edx
+	testl $0x02000000,(%edx)
+	jz 1f
+	stmxcsr 4(%esp)
+	or 4(%esp),%eax
+1:	and %ecx,%eax
+	ret
diff --git a/libc/src/musl/math/acos.c b/libc/src/musl/math/acos.c
deleted file mode 100644
index ea9c87b..0000000
--- a/libc/src/musl/math/acos.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_acos.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* acos(x)
- * Method :
- *      acos(x)  = pi/2 - asin(x)
- *      acos(-x) = pi/2 + asin(x)
- * For |x|<=0.5
- *      acos(x) = pi/2 - (x + x*x^2*R(x^2))     (see asin.c)
- * For x>0.5
- *      acos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
- *              = 2asin(sqrt((1-x)/2))
- *              = 2s + 2s*z*R(z)        ...z=(1-x)/2, s=sqrt(z)
- *              = 2f + (2c + 2s*z*R(z))
- *     where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
- *     for f so that f+c ~ sqrt(z).
- * For x<-0.5
- *      acos(x) = pi - 2asin(sqrt((1-|x|)/2))
- *              = pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)
- *
- * Special cases:
- *      if x is NaN, return x itself;
- *      if |x|>1, return NaN with invalid signal.
- *
- * Function needed: sqrt
- */
-
-#include "libm.h"
-
-static const double
-pio2_hi = 1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
-pio2_lo = 6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
-pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
-pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
-pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
-pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
-pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
-pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
-qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
-qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
-qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
-qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
-
-static double R(double z)
-{
-	double_t p, q;
-	p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
-	q = 1.0+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
-	return p/q;
-}
-
-double acos(double x)
-{
-	double z,w,s,c,df;
-	uint32_t hx,ix;
-
-	GET_HIGH_WORD(hx, x);
-	ix = hx & 0x7fffffff;
-	/* |x| >= 1 or nan */
-	if (ix >= 0x3ff00000) {
-		uint32_t lx;
-
-		GET_LOW_WORD(lx,x);
-		if ((ix-0x3ff00000 | lx) == 0) {
-			/* acos(1)=0, acos(-1)=pi */
-			if (hx >> 31)
-				return 2*pio2_hi + 0x1p-120f;
-			return 0;
-		}
-		return 0/(x-x);
-	}
-	/* |x| < 0.5 */
-	if (ix < 0x3fe00000) {
-		if (ix <= 0x3c600000)  /* |x| < 2**-57 */
-			return pio2_hi + 0x1p-120f;
-		return pio2_hi - (x - (pio2_lo-x*R(x*x)));
-	}
-	/* x < -0.5 */
-	if (hx >> 31) {
-		z = (1.0+x)*0.5;
-		s = sqrt(z);
-		w = R(z)*s-pio2_lo;
-		return 2*(pio2_hi - (s+w));
-	}
-	/* x > 0.5 */
-	z = (1.0-x)*0.5;
-	s = sqrt(z);
-	df = s;
-	SET_LOW_WORD(df,0);
-	c = (z-df*df)/(s+df);
-	w = R(z)*s+c;
-	return 2*(df+w);
-}
diff --git a/libc/src/musl/math/acosf.c b/libc/src/musl/math/acosf.c
deleted file mode 100644
index 8ee1a71..0000000
--- a/libc/src/musl/math/acosf.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_acosf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float
-pio2_hi = 1.5707962513e+00, /* 0x3fc90fda */
-pio2_lo = 7.5497894159e-08, /* 0x33a22168 */
-pS0 =  1.6666586697e-01,
-pS1 = -4.2743422091e-02,
-pS2 = -8.6563630030e-03,
-qS1 = -7.0662963390e-01;
-
-static float R(float z)
-{
-	float_t p, q;
-	p = z*(pS0+z*(pS1+z*pS2));
-	q = 1.0f+z*qS1;
-	return p/q;
-}
-
-float acosf(float x)
-{
-	float z,w,s,c,df;
-	uint32_t hx,ix;
-
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
-	/* |x| >= 1 or nan */
-	if (ix >= 0x3f800000) {
-		if (ix == 0x3f800000) {
-			if (hx >> 31)
-				return 2*pio2_hi + 0x1p-120f;
-			return 0;
-		}
-		return 0/(x-x);
-	}
-	/* |x| < 0.5 */
-	if (ix < 0x3f000000) {
-		if (ix <= 0x32800000) /* |x| < 2**-26 */
-			return pio2_hi + 0x1p-120f;
-		return pio2_hi - (x - (pio2_lo-x*R(x*x)));
-	}
-	/* x < -0.5 */
-	if (hx >> 31) {
-		z = (1+x)*0.5f;
-		s = sqrtf(z);
-		w = R(z)*s-pio2_lo;
-		return 2*(pio2_hi - (s+w));
-	}
-	/* x > 0.5 */
-	z = (1-x)*0.5f;
-	s = sqrtf(z);
-	GET_FLOAT_WORD(hx,s);
-	SET_FLOAT_WORD(df,hx&0xfffff000);
-	c = (z-df*df)/(s+df);
-	w = R(z)*s+c;
-	return 2*(df+w);
-}
diff --git a/libc/src/musl/math/acosl.c b/libc/src/musl/math/acosl.c
deleted file mode 100644
index c03bdf0..0000000
--- a/libc/src/musl/math/acosl.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_acosl.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * See comments in acos.c.
- * Converted to long double by David Schultz <das@FreeBSD.ORG>.
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double acosl(long double x)
-{
-	return acos(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-#include "__invtrigl.h"
-#if LDBL_MANT_DIG == 64
-#define CLEARBOTTOM(u) (u.i.m &= -1ULL << 32)
-#elif LDBL_MANT_DIG == 113
-#define CLEARBOTTOM(u) (u.i.lo = 0)
-#endif
-
-long double acosl(long double x)
-{
-	union ldshape u = {x};
-	long double z, s, c, f;
-	uint16_t e = u.i.se & 0x7fff;
-
-	/* |x| >= 1 or nan */
-	if (e >= 0x3fff) {
-		if (x == 1)
-			return 0;
-		if (x == -1)
-			return 2*pio2_hi + 0x1p-120f;
-		return 0/(x-x);
-	}
-	/* |x| < 0.5 */
-	if (e < 0x3fff - 1) {
-		if (e < 0x3fff - LDBL_MANT_DIG - 1)
-			return pio2_hi + 0x1p-120f;
-		return pio2_hi - (__invtrigl_R(x*x)*x - pio2_lo + x);
-	}
-	/* x < -0.5 */
-	if (u.i.se >> 15) {
-		z = (1 + x)*0.5;
-		s = sqrtl(z);
-		return 2*(pio2_hi - (__invtrigl_R(z)*s - pio2_lo + s));
-	}
-	/* x > 0.5 */
-	z = (1 - x)*0.5;
-	s = sqrtl(z);
-	u.f = s;
-	CLEARBOTTOM(u);
-	f = u.f;
-	c = (z - f*f)/(s + f);
-	return 2*(__invtrigl_R(z)*s + c + f);
-}
-#endif
diff --git a/libc/src/musl/math/asin.c b/libc/src/musl/math/asin.c
deleted file mode 100644
index c926b18..0000000
--- a/libc/src/musl/math/asin.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_asin.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* asin(x)
- * Method :
- *      Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
- *      we approximate asin(x) on [0,0.5] by
- *              asin(x) = x + x*x^2*R(x^2)
- *      where
- *              R(x^2) is a rational approximation of (asin(x)-x)/x^3
- *      and its remez error is bounded by
- *              |(asin(x)-x)/x^3 - R(x^2)| < 2^(-58.75)
- *
- *      For x in [0.5,1]
- *              asin(x) = pi/2-2*asin(sqrt((1-x)/2))
- *      Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
- *      then for x>0.98
- *              asin(x) = pi/2 - 2*(s+s*z*R(z))
- *                      = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
- *      For x<=0.98, let pio4_hi = pio2_hi/2, then
- *              f = hi part of s;
- *              c = sqrt(z) - f = (z-f*f)/(s+f)         ...f+c=sqrt(z)
- *      and
- *              asin(x) = pi/2 - 2*(s+s*z*R(z))
- *                      = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
- *                      = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
- *
- * Special cases:
- *      if x is NaN, return x itself;
- *      if |x|>1, return NaN with invalid signal.
- *
- */
-
-#include "libm.h"
-
-static const double
-pio2_hi = 1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
-pio2_lo = 6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
-/* coefficients for R(x^2) */
-pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
-pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
-pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
-pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
-pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
-pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
-qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
-qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
-qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
-qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */
-
-static double R(double z)
-{
-	double_t p, q;
-	p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
-	q = 1.0+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
-	return p/q;
-}
-
-double asin(double x)
-{
-	double z,r,s;
-	uint32_t hx,ix;
-
-	GET_HIGH_WORD(hx, x);
-	ix = hx & 0x7fffffff;
-	/* |x| >= 1 or nan */
-	if (ix >= 0x3ff00000) {
-		uint32_t lx;
-		GET_LOW_WORD(lx, x);
-		if ((ix-0x3ff00000 | lx) == 0)
-			/* asin(1) = +-pi/2 with inexact */
-			return x*pio2_hi + 0x1p-120f;
-		return 0/(x-x);
-	}
-	/* |x| < 0.5 */
-	if (ix < 0x3fe00000) {
-		/* if 0x1p-1022 <= |x| < 0x1p-26, avoid raising underflow */
-		if (ix < 0x3e500000 && ix >= 0x00100000)
-			return x;
-		return x + x*R(x*x);
-	}
-	/* 1 > |x| >= 0.5 */
-	z = (1 - fabs(x))*0.5;
-	s = sqrt(z);
-	r = R(z);
-	if (ix >= 0x3fef3333) {  /* if |x| > 0.975 */
-		x = pio2_hi-(2*(s+s*r)-pio2_lo);
-	} else {
-		double f,c;
-		/* f+c = sqrt(z) */
-		f = s;
-		SET_LOW_WORD(f,0);
-		c = (z-f*f)/(s+f);
-		x = 0.5*pio2_hi - (2*s*r - (pio2_lo-2*c) - (0.5*pio2_hi-2*f));
-	}
-	if (hx >> 31)
-		return -x;
-	return x;
-}
diff --git a/libc/src/musl/math/asinf.c b/libc/src/musl/math/asinf.c
deleted file mode 100644
index bcd304a..0000000
--- a/libc/src/musl/math/asinf.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_asinf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-#include "libm.h"
-
-static const double
-pio2 = 1.570796326794896558e+00;
-
-static const float
-/* coefficients for R(x^2) */
-pS0 =  1.6666586697e-01,
-pS1 = -4.2743422091e-02,
-pS2 = -8.6563630030e-03,
-qS1 = -7.0662963390e-01;
-
-static float R(float z)
-{
-	float_t p, q;
-	p = z*(pS0+z*(pS1+z*pS2));
-	q = 1.0f+z*qS1;
-	return p/q;
-}
-
-float asinf(float x)
-{
-	double s;
-	float z;
-	uint32_t hx,ix;
-
-	GET_FLOAT_WORD(hx, x);
-	ix = hx & 0x7fffffff;
-	if (ix >= 0x3f800000) {  /* |x| >= 1 */
-		if (ix == 0x3f800000)  /* |x| == 1 */
-			return x*pio2 + 0x1p-120f;  /* asin(+-1) = +-pi/2 with inexact */
-		return 0/(x-x);  /* asin(|x|>1) is NaN */
-	}
-	if (ix < 0x3f000000) {  /* |x| < 0.5 */
-		/* if 0x1p-126 <= |x| < 0x1p-12, avoid raising underflow */
-		if (ix < 0x39800000 && ix >= 0x00800000)
-			return x;
-		return x + x*R(x*x);
-	}
-	/* 1 > |x| >= 0.5 */
-	z = (1 - fabsf(x))*0.5f;
-	s = sqrt(z);
-	x = pio2 - 2*(s+s*R(z));
-	if (hx >> 31)
-		return -x;
-	return x;
-}
diff --git a/libc/src/musl/math/asinl.c b/libc/src/musl/math/asinl.c
deleted file mode 100644
index 347c535..0000000
--- a/libc/src/musl/math/asinl.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_asinl.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * See comments in asin.c.
- * Converted to long double by David Schultz <das@FreeBSD.ORG>.
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double asinl(long double x)
-{
-	return asin(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-#include "__invtrigl.h"
-#if LDBL_MANT_DIG == 64
-#define CLOSETO1(u) (u.i.m>>56 >= 0xf7)
-#define CLEARBOTTOM(u) (u.i.m &= -1ULL << 32)
-#elif LDBL_MANT_DIG == 113
-#define CLOSETO1(u) (u.i.top >= 0xee00)
-#define CLEARBOTTOM(u) (u.i.lo = 0)
-#endif
-
-long double asinl(long double x)
-{
-	union ldshape u = {x};
-	long double z, r, s;
-	uint16_t e = u.i.se & 0x7fff;
-	int sign = u.i.se >> 15;
-
-	if (e >= 0x3fff) {   /* |x| >= 1 or nan */
-		/* asin(+-1)=+-pi/2 with inexact */
-		if (x == 1 || x == -1)
-			return x*pio2_hi + 0x1p-120f;
-		return 0/(x-x);
-	}
-	if (e < 0x3fff - 1) {  /* |x| < 0.5 */
-		if (e < 0x3fff - (LDBL_MANT_DIG+1)/2) {
-			/* return x with inexact if x!=0 */
-			FORCE_EVAL(x + 0x1p120f);
-			return x;
-		}
-		return x + x*__invtrigl_R(x*x);
-	}
-	/* 1 > |x| >= 0.5 */
-	z = (1.0 - fabsl(x))*0.5;
-	s = sqrtl(z);
-	r = __invtrigl_R(z);
-	if (CLOSETO1(u)) {
-		x = pio2_hi - (2*(s+s*r)-pio2_lo);
-	} else {
-		long double f, c;
-		u.f = s;
-		CLEARBOTTOM(u);
-		f = u.f;
-		c = (z - f*f)/(s + f);
-		x = 0.5*pio2_hi-(2*s*r - (pio2_lo-2*c) - (0.5*pio2_hi-2*f));
-	}
-	return sign ? -x : x;
-}
-#endif
diff --git a/libc/src/musl/math/atan.c b/libc/src/musl/math/atan.c
deleted file mode 100644
index 63b0ab2..0000000
--- a/libc/src/musl/math/atan.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_atan.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* atan(x)
- * Method
- *   1. Reduce x to positive by atan(x) = -atan(-x).
- *   2. According to the integer k=4t+0.25 chopped, t=x, the argument
- *      is further reduced to one of the following intervals and the
- *      arctangent of t is evaluated by the corresponding formula:
- *
- *      [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)
- *      [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )
- *      [11/16.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
- *      [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) )
- *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
- *
- * Constants:
- * The hexadecimal values are the intended ones for the following
- * constants. The decimal values may be used, provided that the
- * compiler will convert from decimal to binary accurately enough
- * to produce the hexadecimal values shown.
- */
-
-
-#include "libm.h"
-
-static const double atanhi[] = {
-  4.63647609000806093515e-01, /* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
-  7.85398163397448278999e-01, /* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
-  9.82793723247329054082e-01, /* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
-  1.57079632679489655800e+00, /* atan(inf)hi 0x3FF921FB, 0x54442D18 */
-};
-
-static const double atanlo[] = {
-  2.26987774529616870924e-17, /* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
-  3.06161699786838301793e-17, /* atan(1.0)lo 0x3C81A626, 0x33145C07 */
-  1.39033110312309984516e-17, /* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
-  6.12323399573676603587e-17, /* atan(inf)lo 0x3C91A626, 0x33145C07 */
-};
-
-static const double aT[] = {
-  3.33333333333329318027e-01, /* 0x3FD55555, 0x5555550D */
- -1.99999999998764832476e-01, /* 0xBFC99999, 0x9998EBC4 */
-  1.42857142725034663711e-01, /* 0x3FC24924, 0x920083FF */
- -1.11111104054623557880e-01, /* 0xBFBC71C6, 0xFE231671 */
-  9.09088713343650656196e-02, /* 0x3FB745CD, 0xC54C206E */
- -7.69187620504482999495e-02, /* 0xBFB3B0F2, 0xAF749A6D */
-  6.66107313738753120669e-02, /* 0x3FB10D66, 0xA0D03D51 */
- -5.83357013379057348645e-02, /* 0xBFADDE2D, 0x52DEFD9A */
-  4.97687799461593236017e-02, /* 0x3FA97B4B, 0x24760DEB */
- -3.65315727442169155270e-02, /* 0xBFA2B444, 0x2C6A6C2F */
-  1.62858201153657823623e-02, /* 0x3F90AD3A, 0xE322DA11 */
-};
-
-double atan(double x)
-{
-	double_t w,s1,s2,z;
-	uint32_t ix,sign;
-	int id;
-
-	GET_HIGH_WORD(ix, x);
-	sign = ix >> 31;
-	ix &= 0x7fffffff;
-	if (ix >= 0x44100000) {   /* if |x| >= 2^66 */
-		if (isnan(x))
-			return x;
-		z = atanhi[3] + 0x1p-120f;
-		return sign ? -z : z;
-	}
-	if (ix < 0x3fdc0000) {    /* |x| < 0.4375 */
-		if (ix < 0x3e400000) {  /* |x| < 2^-27 */
-			if (ix < 0x00100000)
-				/* raise underflow for subnormal x */
-				FORCE_EVAL((float)x);
-			return x;
-		}
-		id = -1;
-	} else {
-		x = fabs(x);
-		if (ix < 0x3ff30000) {  /* |x| < 1.1875 */
-			if (ix < 0x3fe60000) {  /*  7/16 <= |x| < 11/16 */
-				id = 0;
-				x = (2.0*x-1.0)/(2.0+x);
-			} else {                /* 11/16 <= |x| < 19/16 */
-				id = 1;
-				x = (x-1.0)/(x+1.0);
-			}
-		} else {
-			if (ix < 0x40038000) {  /* |x| < 2.4375 */
-				id = 2;
-				x = (x-1.5)/(1.0+1.5*x);
-			} else {                /* 2.4375 <= |x| < 2^66 */
-				id = 3;
-				x = -1.0/x;
-			}
-		}
-	}
-	/* end of argument reduction */
-	z = x*x;
-	w = z*z;
-	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
-	s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));
-	s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));
-	if (id < 0)
-		return x - x*(s1+s2);
-	z = atanhi[id] - (x*(s1+s2) - atanlo[id] - x);
-	return sign ? -z : z;
-}
diff --git a/libc/src/musl/math/atan2.c b/libc/src/musl/math/atan2.c
deleted file mode 100644
index 5a1903c..0000000
--- a/libc/src/musl/math/atan2.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_atan2.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- *
- */
-/* atan2(y,x)
- * Method :
- *      1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
- *      2. Reduce x to positive by (if x and y are unexceptional):
- *              ARG (x+iy) = arctan(y/x)           ... if x > 0,
- *              ARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,
- *
- * Special cases:
- *
- *      ATAN2((anything), NaN ) is NaN;
- *      ATAN2(NAN , (anything) ) is NaN;
- *      ATAN2(+-0, +(anything but NaN)) is +-0  ;
- *      ATAN2(+-0, -(anything but NaN)) is +-pi ;
- *      ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
- *      ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
- *      ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
- *      ATAN2(+-INF,+INF ) is +-pi/4 ;
- *      ATAN2(+-INF,-INF ) is +-3pi/4;
- *      ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
- *
- * Constants:
- * The hexadecimal values are the intended ones for the following
- * constants. The decimal values may be used, provided that the
- * compiler will convert from decimal to binary accurately enough
- * to produce the hexadecimal values shown.
- */
-
-#include "libm.h"
-
-static const double
-pi     = 3.1415926535897931160E+00, /* 0x400921FB, 0x54442D18 */
-pi_lo  = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */
-
-double atan2(double y, double x)
-{
-	double z;
-	uint32_t m,lx,ly,ix,iy;
-
-	if (isnan(x) || isnan(y))
-		return x+y;
-	EXTRACT_WORDS(ix, lx, x);
-	EXTRACT_WORDS(iy, ly, y);
-	if ((ix-0x3ff00000 | lx) == 0)  /* x = 1.0 */
-		return atan(y);
-	m = ((iy>>31)&1) | ((ix>>30)&2);  /* 2*sign(x)+sign(y) */
-	ix = ix & 0x7fffffff;
-	iy = iy & 0x7fffffff;
-
-	/* when y = 0 */
-	if ((iy|ly) == 0) {
-		switch(m) {
-		case 0:
-		case 1: return y;   /* atan(+-0,+anything)=+-0 */
-		case 2: return  pi; /* atan(+0,-anything) = pi */
-		case 3: return -pi; /* atan(-0,-anything) =-pi */
-		}
-	}
-	/* when x = 0 */
-	if ((ix|lx) == 0)
-		return m&1 ? -pi/2 : pi/2;
-	/* when x is INF */
-	if (ix == 0x7ff00000) {
-		if (iy == 0x7ff00000) {
-			switch(m) {
-			case 0: return  pi/4;   /* atan(+INF,+INF) */
-			case 1: return -pi/4;   /* atan(-INF,+INF) */
-			case 2: return  3*pi/4; /* atan(+INF,-INF) */
-			case 3: return -3*pi/4; /* atan(-INF,-INF) */
-			}
-		} else {
-			switch(m) {
-			case 0: return  0.0; /* atan(+...,+INF) */
-			case 1: return -0.0; /* atan(-...,+INF) */
-			case 2: return  pi;  /* atan(+...,-INF) */
-			case 3: return -pi;  /* atan(-...,-INF) */
-			}
-		}
-	}
-	/* |y/x| > 0x1p64 */
-	if (ix+(64<<20) < iy || iy == 0x7ff00000)
-		return m&1 ? -pi/2 : pi/2;
-
-	/* z = atan(|y/x|) without spurious underflow */
-	if ((m&2) && iy+(64<<20) < ix)  /* |y/x| < 0x1p-64, x<0 */
-		z = 0;
-	else
-		z = atan(fabs(y/x));
-	switch (m) {
-	case 0: return z;              /* atan(+,+) */
-	case 1: return -z;             /* atan(-,+) */
-	case 2: return pi - (z-pi_lo); /* atan(+,-) */
-	default: /* case 3 */
-		return (z-pi_lo) - pi; /* atan(-,-) */
-	}
-}
diff --git a/libc/src/musl/math/atan2f.c b/libc/src/musl/math/atan2f.c
deleted file mode 100644
index c634d00..0000000
--- a/libc/src/musl/math/atan2f.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_atan2f.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float
-pi     = 3.1415927410e+00, /* 0x40490fdb */
-pi_lo  = -8.7422776573e-08; /* 0xb3bbbd2e */
-
-float atan2f(float y, float x)
-{
-	float z;
-	uint32_t m,ix,iy;
-
-	if (isnan(x) || isnan(y))
-		return x+y;
-	GET_FLOAT_WORD(ix, x);
-	GET_FLOAT_WORD(iy, y);
-	if (ix == 0x3f800000)  /* x=1.0 */
-		return atanf(y);
-	m = ((iy>>31)&1) | ((ix>>30)&2);  /* 2*sign(x)+sign(y) */
-	ix &= 0x7fffffff;
-	iy &= 0x7fffffff;
-
-	/* when y = 0 */
-	if (iy == 0) {
-		switch (m) {
-		case 0:
-		case 1: return y;   /* atan(+-0,+anything)=+-0 */
-		case 2: return  pi; /* atan(+0,-anything) = pi */
-		case 3: return -pi; /* atan(-0,-anything) =-pi */
-		}
-	}
-	/* when x = 0 */
-	if (ix == 0)
-		return m&1 ? -pi/2 : pi/2;
-	/* when x is INF */
-	if (ix == 0x7f800000) {
-		if (iy == 0x7f800000) {
-			switch (m) {
-			case 0: return  pi/4; /* atan(+INF,+INF) */
-			case 1: return -pi/4; /* atan(-INF,+INF) */
-			case 2: return 3*pi/4;  /*atan(+INF,-INF)*/
-			case 3: return -3*pi/4; /*atan(-INF,-INF)*/
-			}
-		} else {
-			switch (m) {
-			case 0: return  0.0f;    /* atan(+...,+INF) */
-			case 1: return -0.0f;    /* atan(-...,+INF) */
-			case 2: return  pi; /* atan(+...,-INF) */
-			case 3: return -pi; /* atan(-...,-INF) */
-			}
-		}
-	}
-	/* |y/x| > 0x1p26 */
-	if (ix+(26<<23) < iy || iy == 0x7f800000)
-		return m&1 ? -pi/2 : pi/2;
-
-	/* z = atan(|y/x|) with correct underflow */
-	if ((m&2) && iy+(26<<23) < ix)  /*|y/x| < 0x1p-26, x < 0 */
-		z = 0.0;
-	else
-		z = atanf(fabsf(y/x));
-	switch (m) {
-	case 0: return z;              /* atan(+,+) */
-	case 1: return -z;             /* atan(-,+) */
-	case 2: return pi - (z-pi_lo); /* atan(+,-) */
-	default: /* case 3 */
-		return (z-pi_lo) - pi; /* atan(-,-) */
-	}
-}
diff --git a/libc/src/musl/math/atan2l.c b/libc/src/musl/math/atan2l.c
deleted file mode 100644
index f0937a9..0000000
--- a/libc/src/musl/math/atan2l.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_atan2l.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- *
- */
-/*
- * See comments in atan2.c.
- * Converted to long double by David Schultz <das@FreeBSD.ORG>.
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double atan2l(long double y, long double x)
-{
-	return atan2(y, x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-#include "__invtrigl.h"
-
-long double atan2l(long double y, long double x)
-{
-	union ldshape ux, uy;
-	long double z;
-	int m, ex, ey;
-
-	if (isnan(x) || isnan(y))
-		return x+y;
-	if (x == 1)
-		return atanl(y);
-	ux.f = x;
-	uy.f = y;
-	ex = ux.i.se & 0x7fff;
-	ey = uy.i.se & 0x7fff;
-	m = 2*(ux.i.se>>15) | uy.i.se>>15;
-	if (y == 0) {
-		switch(m) {
-		case 0:
-		case 1: return y;           /* atan(+-0,+anything)=+-0 */
-		case 2: return  2*pio2_hi;  /* atan(+0,-anything) = pi */
-		case 3: return -2*pio2_hi;  /* atan(-0,-anything) =-pi */
-		}
-	}
-	if (x == 0)
-		return m&1 ? -pio2_hi : pio2_hi;
-	if (ex == 0x7fff) {
-		if (ey == 0x7fff) {
-			switch(m) {
-			case 0: return  pio2_hi/2;   /* atan(+INF,+INF) */
-			case 1: return -pio2_hi/2;   /* atan(-INF,+INF) */
-			case 2: return  1.5*pio2_hi; /* atan(+INF,-INF) */
-			case 3: return -1.5*pio2_hi; /* atan(-INF,-INF) */
-			}
-		} else {
-			switch(m) {
-			case 0: return  0.0;        /* atan(+...,+INF) */
-			case 1: return -0.0;        /* atan(-...,+INF) */
-			case 2: return  2*pio2_hi;  /* atan(+...,-INF) */
-			case 3: return -2*pio2_hi;  /* atan(-...,-INF) */
-			}
-		}
-	}
-	if (ex+120 < ey || ey == 0x7fff)
-		return m&1 ? -pio2_hi : pio2_hi;
-	/* z = atan(|y/x|) without spurious underflow */
-	if ((m&2) && ey+120 < ex)  /* |y/x| < 0x1p-120, x<0 */
-		z = 0.0;
-	else
-		z = atanl(fabsl(y/x));
-	switch (m) {
-	case 0: return z;               /* atan(+,+) */
-	case 1: return -z;              /* atan(-,+) */
-	case 2: return 2*pio2_hi-(z-2*pio2_lo); /* atan(+,-) */
-	default: /* case 3 */
-		return (z-2*pio2_lo)-2*pio2_hi; /* atan(-,-) */
-	}
-}
-#endif
diff --git a/libc/src/musl/math/atanf.c b/libc/src/musl/math/atanf.c
deleted file mode 100644
index 178341b..0000000
--- a/libc/src/musl/math/atanf.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_atanf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-
-#include "libm.h"
-
-static const float atanhi[] = {
-  4.6364760399e-01, /* atan(0.5)hi 0x3eed6338 */
-  7.8539812565e-01, /* atan(1.0)hi 0x3f490fda */
-  9.8279368877e-01, /* atan(1.5)hi 0x3f7b985e */
-  1.5707962513e+00, /* atan(inf)hi 0x3fc90fda */
-};
-
-static const float atanlo[] = {
-  5.0121582440e-09, /* atan(0.5)lo 0x31ac3769 */
-  3.7748947079e-08, /* atan(1.0)lo 0x33222168 */
-  3.4473217170e-08, /* atan(1.5)lo 0x33140fb4 */
-  7.5497894159e-08, /* atan(inf)lo 0x33a22168 */
-};
-
-static const float aT[] = {
-  3.3333328366e-01,
- -1.9999158382e-01,
-  1.4253635705e-01,
- -1.0648017377e-01,
-  6.1687607318e-02,
-};
-
-float atanf(float x)
-{
-	float_t w,s1,s2,z;
-	uint32_t ix,sign;
-	int id;
-
-	GET_FLOAT_WORD(ix, x);
-	sign = ix>>31;
-	ix &= 0x7fffffff;
-	if (ix >= 0x4c800000) {  /* if |x| >= 2**26 */
-		if (isnan(x))
-			return x;
-		z = atanhi[3] + 0x1p-120f;
-		return sign ? -z : z;
-	}
-	if (ix < 0x3ee00000) {   /* |x| < 0.4375 */
-		if (ix < 0x39800000) {  /* |x| < 2**-12 */
-			if (ix < 0x00800000)
-				/* raise underflow for subnormal x */
-				FORCE_EVAL(x*x);
-			return x;
-		}
-		id = -1;
-	} else {
-		x = fabsf(x);
-		if (ix < 0x3f980000) {  /* |x| < 1.1875 */
-			if (ix < 0x3f300000) {  /*  7/16 <= |x| < 11/16 */
-				id = 0;
-				x = (2.0f*x - 1.0f)/(2.0f + x);
-			} else {                /* 11/16 <= |x| < 19/16 */
-				id = 1;
-				x = (x - 1.0f)/(x + 1.0f);
-			}
-		} else {
-			if (ix < 0x401c0000) {  /* |x| < 2.4375 */
-				id = 2;
-				x = (x - 1.5f)/(1.0f + 1.5f*x);
-			} else {                /* 2.4375 <= |x| < 2**26 */
-				id = 3;
-				x = -1.0f/x;
-			}
-		}
-	}
-	/* end of argument reduction */
-	z = x*x;
-	w = z*z;
-	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
-	s1 = z*(aT[0]+w*(aT[2]+w*aT[4]));
-	s2 = w*(aT[1]+w*aT[3]);
-	if (id < 0)
-		return x - x*(s1+s2);
-	z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
-	return sign ? -z : z;
-}
diff --git a/libc/src/musl/math/atanl.c b/libc/src/musl/math/atanl.c
deleted file mode 100644
index 79a3edb..0000000
--- a/libc/src/musl/math/atanl.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_atanl.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * See comments in atan.c.
- * Converted to long double by David Schultz <das@FreeBSD.ORG>.
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double atanl(long double x)
-{
-	return atan(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-
-#if LDBL_MANT_DIG == 64
-#define EXPMAN(u) ((u.i.se & 0x7fff)<<8 | (u.i.m>>55 & 0xff))
-
-static const long double atanhi[] = {
-	 4.63647609000806116202e-01L,
-	 7.85398163397448309628e-01L,
-	 9.82793723247329067960e-01L,
-	 1.57079632679489661926e+00L,
-};
-
-static const long double atanlo[] = {
-	 1.18469937025062860669e-20L,
-	-1.25413940316708300586e-20L,
-	 2.55232234165405176172e-20L,
-	-2.50827880633416601173e-20L,
-};
-
-static const long double aT[] = {
-	 3.33333333333333333017e-01L,
-	-1.99999999999999632011e-01L,
-	 1.42857142857046531280e-01L,
-	-1.11111111100562372733e-01L,
-	 9.09090902935647302252e-02L,
-	-7.69230552476207730353e-02L,
-	 6.66661718042406260546e-02L,
-	-5.88158892835030888692e-02L,
-	 5.25499891539726639379e-02L,
-	-4.70119845393155721494e-02L,
-	 4.03539201366454414072e-02L,
-	-2.91303858419364158725e-02L,
-	 1.24822046299269234080e-02L,
-};
-
-static long double T_even(long double x)
-{
-	return aT[0] + x * (aT[2] + x * (aT[4] + x * (aT[6] +
-		x * (aT[8] + x * (aT[10] + x * aT[12])))));
-}
-
-static long double T_odd(long double x)
-{
-	return aT[1] + x * (aT[3] + x * (aT[5] + x * (aT[7] +
-		x * (aT[9] + x * aT[11]))));
-}
-#elif LDBL_MANT_DIG == 113
-#define EXPMAN(u) ((u.i.se & 0x7fff)<<8 | u.i.top>>8)
-
-const long double atanhi[] = {
-	 4.63647609000806116214256231461214397e-01L,
-	 7.85398163397448309615660845819875699e-01L,
-	 9.82793723247329067985710611014666038e-01L,
-	 1.57079632679489661923132169163975140e+00L,
-};
-
-const long double atanlo[] = {
-	 4.89509642257333492668618435220297706e-36L,
-	 2.16795253253094525619926100651083806e-35L,
-	-2.31288434538183565909319952098066272e-35L,
-	 4.33590506506189051239852201302167613e-35L,
-};
-
-const long double aT[] = {
-	 3.33333333333333333333333333333333125e-01L,
-	-1.99999999999999999999999999999180430e-01L,
-	 1.42857142857142857142857142125269827e-01L,
-	-1.11111111111111111111110834490810169e-01L,
-	 9.09090909090909090908522355708623681e-02L,
-	-7.69230769230769230696553844935357021e-02L,
-	 6.66666666666666660390096773046256096e-02L,
-	-5.88235294117646671706582985209643694e-02L,
-	 5.26315789473666478515847092020327506e-02L,
-	-4.76190476189855517021024424991436144e-02L,
-	 4.34782608678695085948531993458097026e-02L,
-	-3.99999999632663469330634215991142368e-02L,
-	 3.70370363987423702891250829918659723e-02L,
-	-3.44827496515048090726669907612335954e-02L,
-	 3.22579620681420149871973710852268528e-02L,
-	-3.03020767654269261041647570626778067e-02L,
-	 2.85641979882534783223403715930946138e-02L,
-	-2.69824879726738568189929461383741323e-02L,
-	 2.54194698498808542954187110873675769e-02L,
-	-2.35083879708189059926183138130183215e-02L,
-	 2.04832358998165364349957325067131428e-02L,
-	-1.54489555488544397858507248612362957e-02L,
-	 8.64492360989278761493037861575248038e-03L,
-	-2.58521121597609872727919154569765469e-03L,
-};
-
-static long double T_even(long double x)
-{
-	return (aT[0] + x * (aT[2] + x * (aT[4] + x * (aT[6] + x * (aT[8] +
-		x * (aT[10] + x * (aT[12] + x * (aT[14] + x * (aT[16] +
-		x * (aT[18] + x * (aT[20] + x * aT[22])))))))))));
-}
-
-static long double T_odd(long double x)
-{
-	return (aT[1] + x * (aT[3] + x * (aT[5] + x * (aT[7] + x * (aT[9] +
-		x * (aT[11] + x * (aT[13] + x * (aT[15] + x * (aT[17] +
-		x * (aT[19] + x * (aT[21] + x * aT[23])))))))))));
-}
-#endif
-
-long double atanl(long double x)
-{
-	union ldshape u = {x};
-	long double w, s1, s2, z;
-	int id;
-	unsigned e = u.i.se & 0x7fff;
-	unsigned sign = u.i.se >> 15;
-	unsigned expman;
-
-	if (e >= 0x3fff + LDBL_MANT_DIG + 1) { /* if |x| is large, atan(x)~=pi/2 */
-		if (isnan(x))
-			return x;
-		return sign ? -atanhi[3] : atanhi[3];
-	}
-	/* Extract the exponent and the first few bits of the mantissa. */
-	expman = EXPMAN(u);
-	if (expman < ((0x3fff - 2) << 8) + 0xc0) {  /* |x| < 0.4375 */
-		if (e < 0x3fff - (LDBL_MANT_DIG+1)/2) {   /* if |x| is small, atanl(x)~=x */
-			/* raise underflow if subnormal */
-			if (e == 0)
-				FORCE_EVAL((float)x);
-			return x;
-		}
-		id = -1;
-	} else {
-		x = fabsl(x);
-		if (expman < (0x3fff << 8) + 0x30) {  /* |x| < 1.1875 */
-			if (expman < ((0x3fff - 1) << 8) + 0x60) { /*  7/16 <= |x| < 11/16 */
-				id = 0;
-				x = (2.0*x-1.0)/(2.0+x);
-			} else {                                 /* 11/16 <= |x| < 19/16 */
-				id = 1;
-				x = (x-1.0)/(x+1.0);
-			}
-		} else {
-			if (expman < ((0x3fff + 1) << 8) + 0x38) { /* |x| < 2.4375 */
-				id = 2;
-				x = (x-1.5)/(1.0+1.5*x);
-			} else {                                 /* 2.4375 <= |x| */
-				id = 3;
-				x = -1.0/x;
-			}
-		}
-	}
-	/* end of argument reduction */
-	z = x*x;
-	w = z*z;
-	/* break sum aT[i]z**(i+1) into odd and even poly */
-	s1 = z*T_even(w);
-	s2 = w*T_odd(w);
-	if (id < 0)
-		return x - x*(s1+s2);
-	z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
-	return sign ? -z : z;
-}
-#endif
diff --git a/libc/src/musl/math/ceil.c b/libc/src/musl/math/ceil.c
deleted file mode 100644
index b13e6f2..0000000
--- a/libc/src/musl/math/ceil.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include "libm.h"
-
-#if FLT_EVAL_METHOD==0 || FLT_EVAL_METHOD==1
-#define EPS DBL_EPSILON
-#elif FLT_EVAL_METHOD==2
-#define EPS LDBL_EPSILON
-#endif
-static const double_t toint = 1/EPS;
-
-double ceil(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	int e = u.i >> 52 & 0x7ff;
-	double_t y;
-
-	if (e >= 0x3ff+52 || x == 0)
-		return x;
-	/* y = int(x) - x, where int(x) is an integer neighbor of x */
-	if (u.i >> 63)
-		y = x - toint + toint - x;
-	else
-		y = x + toint - toint - x;
-	/* special case because of non-nearest rounding modes */
-	if (e <= 0x3ff-1) {
-		FORCE_EVAL(y);
-		return u.i >> 63 ? -0.0 : 1;
-	}
-	if (y < 0)
-		return x + y + 1;
-	return x + y;
-}
diff --git a/libc/src/musl/math/ceilf.c b/libc/src/musl/math/ceilf.c
deleted file mode 100644
index 869835f..0000000
--- a/libc/src/musl/math/ceilf.c
+++ /dev/null
@@ -1,27 +0,0 @@
-#include "libm.h"
-
-float ceilf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
-	uint32_t m;
-
-	if (e >= 23)
-		return x;
-	if (e >= 0) {
-		m = 0x007fffff >> e;
-		if ((u.i & m) == 0)
-			return x;
-		FORCE_EVAL(x + 0x1p120f);
-		if (u.i >> 31 == 0)
-			u.i += m;
-		u.i &= ~m;
-	} else {
-		FORCE_EVAL(x + 0x1p120f);
-		if (u.i >> 31)
-			u.f = -0.0;
-		else if (u.i << 1)
-			u.f = 1.0;
-	}
-	return u.f;
-}
diff --git a/libc/src/musl/math/ceill.c b/libc/src/musl/math/ceill.c
deleted file mode 100644
index 60a8302..0000000
--- a/libc/src/musl/math/ceill.c
+++ /dev/null
@@ -1,34 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double ceill(long double x)
-{
-	return ceil(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-
-static const long double toint = 1/LDBL_EPSILON;
-
-long double ceill(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	long double y;
-
-	if (e >= 0x3fff+LDBL_MANT_DIG-1 || x == 0)
-		return x;
-	/* y = int(x) - x, where int(x) is an integer neighbor of x */
-	if (u.i.se >> 15)
-		y = x - toint + toint - x;
-	else
-		y = x + toint - toint - x;
-	/* special case because of non-nearest rounding modes */
-	if (e <= 0x3fff-1) {
-		FORCE_EVAL(y);
-		return u.i.se >> 15 ? -0.0 : 1;
-	}
-	if (y < 0)
-		return x + y + 1;
-	return x + y;
-}
-#endif
diff --git a/libc/src/musl/math/exp.c b/libc/src/musl/math/exp.c
deleted file mode 100644
index 9ea672f..0000000
--- a/libc/src/musl/math/exp.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_exp.c */
-/*
- * ====================================================
- * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* exp(x)
- * Returns the exponential of x.
- *
- * Method
- *   1. Argument reduction:
- *      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.
- *      Given x, find r and integer k such that
- *
- *               x = k*ln2 + r,  |r| <= 0.5*ln2.
- *
- *      Here r will be represented as r = hi-lo for better
- *      accuracy.
- *
- *   2. Approximation of exp(r) by a special rational function on
- *      the interval [0,0.34658]:
- *      Write
- *          R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
- *      We use a special Remez algorithm on [0,0.34658] to generate
- *      a polynomial of degree 5 to approximate R. The maximum error
- *      of this polynomial approximation is bounded by 2**-59. In
- *      other words,
- *          R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
- *      (where z=r*r, and the values of P1 to P5 are listed below)
- *      and
- *          |                  5          |     -59
- *          | 2.0+P1*z+...+P5*z   -  R(z) | <= 2
- *          |                             |
- *      The computation of exp(r) thus becomes
- *                              2*r
- *              exp(r) = 1 + ----------
- *                            R(r) - r
- *                                 r*c(r)
- *                     = 1 + r + ----------- (for better accuracy)
- *                                2 - c(r)
- *      where
- *                              2       4             10
- *              c(r) = r - (P1*r  + P2*r  + ... + P5*r   ).
- *
- *   3. Scale back to obtain exp(x):
- *      From step 1, we have
- *         exp(x) = 2^k * exp(r)
- *
- * Special cases:
- *      exp(INF) is INF, exp(NaN) is NaN;
- *      exp(-INF) is 0, and
- *      for finite argument, only exp(0)=1 is exact.
- *
- * Accuracy:
- *      according to an error analysis, the error is always less than
- *      1 ulp (unit in the last place).
- *
- * Misc. info.
- *      For IEEE double
- *          if x >  709.782712893383973096 then exp(x) overflows
- *          if x < -745.133219101941108420 then exp(x) underflows
- */
-
-#include "libm.h"
-
-static const double
-half[2] = {0.5,-0.5},
-ln2hi = 6.93147180369123816490e-01, /* 0x3fe62e42, 0xfee00000 */
-ln2lo = 1.90821492927058770002e-10, /* 0x3dea39ef, 0x35793c76 */
-invln2 = 1.44269504088896338700e+00, /* 0x3ff71547, 0x652b82fe */
-P1   =  1.66666666666666019037e-01, /* 0x3FC55555, 0x5555553E */
-P2   = -2.77777777770155933842e-03, /* 0xBF66C16C, 0x16BEBD93 */
-P3   =  6.61375632143793436117e-05, /* 0x3F11566A, 0xAF25DE2C */
-P4   = -1.65339022054652515390e-06, /* 0xBEBBBD41, 0xC5D26BF1 */
-P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */
-
-double exp(double x)
-{
-	double_t hi, lo, c, xx, y;
-	int k, sign;
-	uint32_t hx;
-
-	GET_HIGH_WORD(hx, x);
-	sign = hx>>31;
-	hx &= 0x7fffffff;  /* high word of |x| */
-
-	/* special cases */
-	if (hx >= 0x4086232b) {  /* if |x| >= 708.39... */
-		if (isnan(x))
-			return x;
-		if (x > 709.782712893383973096) {
-			/* overflow if x!=inf */
-			x *= 0x1p1023;
-			return x;
-		}
-		if (x < -708.39641853226410622) {
-			/* underflow if x!=-inf */
-			FORCE_EVAL((float)(-0x1p-149/x));
-			if (x < -745.13321910194110842)
-				return 0;
-		}
-	}
-
-	/* argument reduction */
-	if (hx > 0x3fd62e42) {  /* if |x| > 0.5 ln2 */
-		if (hx >= 0x3ff0a2b2)  /* if |x| >= 1.5 ln2 */
-			k = (int)(invln2*x + half[sign]);
-		else
-			k = 1 - sign - sign;
-		hi = x - k*ln2hi;  /* k*ln2hi is exact here */
-		lo = k*ln2lo;
-		x = hi - lo;
-	} else if (hx > 0x3e300000)  {  /* if |x| > 2**-28 */
-		k = 0;
-		hi = x;
-		lo = 0;
-	} else {
-		/* inexact if x!=0 */
-		FORCE_EVAL(0x1p1023 + x);
-		return 1 + x;
-	}
-
-	/* x is now in primary range */
-	xx = x*x;
-	c = x - xx*(P1+xx*(P2+xx*(P3+xx*(P4+xx*P5))));
-	y = 1 + (x*c/(2-c) - lo + hi);
-	if (k == 0)
-		return y;
-	return scalbn(y, k);
-}
diff --git a/libc/src/musl/math/exp2.c b/libc/src/musl/math/exp2.c
deleted file mode 100644
index e14adba..0000000
--- a/libc/src/musl/math/exp2.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_exp2.c */
-/*-
- * Copyright (c) 2005 David Schultz <das@FreeBSD.ORG>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "libm.h"
-
-#define TBLSIZE 256
-
-static const double
-redux = 0x1.8p52 / TBLSIZE,
-P1    = 0x1.62e42fefa39efp-1,
-P2    = 0x1.ebfbdff82c575p-3,
-P3    = 0x1.c6b08d704a0a6p-5,
-P4    = 0x1.3b2ab88f70400p-7,
-P5    = 0x1.5d88003875c74p-10;
-
-static const double tbl[TBLSIZE * 2] = {
-/*  exp2(z + eps)          eps     */
-  0x1.6a09e667f3d5dp-1,  0x1.9880p-44,
-  0x1.6b052fa751744p-1,  0x1.8000p-50,
-  0x1.6c012750bd9fep-1, -0x1.8780p-45,
-  0x1.6cfdcddd476bfp-1,  0x1.ec00p-46,
-  0x1.6dfb23c651a29p-1, -0x1.8000p-50,
-  0x1.6ef9298593ae3p-1, -0x1.c000p-52,
-  0x1.6ff7df9519386p-1, -0x1.fd80p-45,
-  0x1.70f7466f42da3p-1, -0x1.c880p-45,
-  0x1.71f75e8ec5fc3p-1,  0x1.3c00p-46,
-  0x1.72f8286eacf05p-1, -0x1.8300p-44,
-  0x1.73f9a48a58152p-1, -0x1.0c00p-47,
-  0x1.74fbd35d7ccfcp-1,  0x1.f880p-45,
-  0x1.75feb564267f1p-1,  0x1.3e00p-47,
-  0x1.77024b1ab6d48p-1, -0x1.7d00p-45,
-  0x1.780694fde5d38p-1, -0x1.d000p-50,
-  0x1.790b938ac1d00p-1,  0x1.3000p-49,
-  0x1.7a11473eb0178p-1, -0x1.d000p-49,
-  0x1.7b17b0976d060p-1,  0x1.0400p-45,
-  0x1.7c1ed0130c133p-1,  0x1.0000p-53,
-  0x1.7d26a62ff8636p-1, -0x1.6900p-45,
-  0x1.7e2f336cf4e3bp-1, -0x1.2e00p-47,
-  0x1.7f3878491c3e8p-1, -0x1.4580p-45,
-  0x1.80427543e1b4ep-1,  0x1.3000p-44,
-  0x1.814d2add1071ap-1,  0x1.f000p-47,
-  0x1.82589994ccd7ep-1, -0x1.1c00p-45,
-  0x1.8364c1eb942d0p-1,  0x1.9d00p-45,
-  0x1.8471a4623cab5p-1,  0x1.7100p-43,
-  0x1.857f4179f5bbcp-1,  0x1.2600p-45,
-  0x1.868d99b4491afp-1, -0x1.2c40p-44,
-  0x1.879cad931a395p-1, -0x1.3000p-45,
-  0x1.88ac7d98a65b8p-1, -0x1.a800p-45,
-  0x1.89bd0a4785800p-1, -0x1.d000p-49,
-  0x1.8ace5422aa223p-1,  0x1.3280p-44,
-  0x1.8be05bad619fap-1,  0x1.2b40p-43,
-  0x1.8cf3216b54383p-1, -0x1.ed00p-45,
-  0x1.8e06a5e08664cp-1, -0x1.0500p-45,
-  0x1.8f1ae99157807p-1,  0x1.8280p-45,
-  0x1.902fed0282c0ep-1, -0x1.cb00p-46,
-  0x1.9145b0b91ff96p-1, -0x1.5e00p-47,
-  0x1.925c353aa2ff9p-1,  0x1.5400p-48,
-  0x1.93737b0cdc64ap-1,  0x1.7200p-46,
-  0x1.948b82b5f98aep-1, -0x1.9000p-47,
-  0x1.95a44cbc852cbp-1,  0x1.5680p-45,
-  0x1.96bdd9a766f21p-1, -0x1.6d00p-44,
-  0x1.97d829fde4e2ap-1, -0x1.1000p-47,
-  0x1.98f33e47a23a3p-1,  0x1.d000p-45,
-  0x1.9a0f170ca0604p-1, -0x1.8a40p-44,
-  0x1.9b2bb4d53ff89p-1,  0x1.55c0p-44,
-  0x1.9c49182a3f15bp-1,  0x1.6b80p-45,
-  0x1.9d674194bb8c5p-1, -0x1.c000p-49,
-  0x1.9e86319e3238ep-1,  0x1.7d00p-46,
-  0x1.9fa5e8d07f302p-1,  0x1.6400p-46,
-  0x1.a0c667b5de54dp-1, -0x1.5000p-48,
-  0x1.a1e7aed8eb8f6p-1,  0x1.9e00p-47,
-  0x1.a309bec4a2e27p-1,  0x1.ad80p-45,
-  0x1.a42c980460a5dp-1, -0x1.af00p-46,
-  0x1.a5503b23e259bp-1,  0x1.b600p-47,
-  0x1.a674a8af46213p-1,  0x1.8880p-44,
-  0x1.a799e1330b3a7p-1,  0x1.1200p-46,
-  0x1.a8bfe53c12e8dp-1,  0x1.6c00p-47,
-  0x1.a9e6b5579fcd2p-1, -0x1.9b80p-45,
-  0x1.ab0e521356fb8p-1,  0x1.b700p-45,
-  0x1.ac36bbfd3f381p-1,  0x1.9000p-50,
-  0x1.ad5ff3a3c2780p-1,  0x1.4000p-49,
-  0x1.ae89f995ad2a3p-1, -0x1.c900p-45,
-  0x1.afb4ce622f367p-1,  0x1.6500p-46,
-  0x1.b0e07298db790p-1,  0x1.fd40p-45,
-  0x1.b20ce6c9a89a9p-1,  0x1.2700p-46,
-  0x1.b33a2b84f1a4bp-1,  0x1.d470p-43,
-  0x1.b468415b747e7p-1, -0x1.8380p-44,
-  0x1.b59728de5593ap-1,  0x1.8000p-54,
-  0x1.b6c6e29f1c56ap-1,  0x1.ad00p-47,
-  0x1.b7f76f2fb5e50p-1,  0x1.e800p-50,
-  0x1.b928cf22749b2p-1, -0x1.4c00p-47,
-  0x1.ba5b030a10603p-1, -0x1.d700p-47,
-  0x1.bb8e0b79a6f66p-1,  0x1.d900p-47,
-  0x1.bcc1e904bc1ffp-1,  0x1.2a00p-47,
-  0x1.bdf69c3f3a16fp-1, -0x1.f780p-46,
-  0x1.bf2c25bd71db8p-1, -0x1.0a00p-46,
-  0x1.c06286141b2e9p-1, -0x1.1400p-46,
-  0x1.c199bdd8552e0p-1,  0x1.be00p-47,
-  0x1.c2d1cd9fa64eep-1, -0x1.9400p-47,
-  0x1.c40ab5fffd02fp-1, -0x1.ed00p-47,
-  0x1.c544778fafd15p-1,  0x1.9660p-44,
-  0x1.c67f12e57d0cbp-1, -0x1.a100p-46,
-  0x1.c7ba88988c1b6p-1, -0x1.8458p-42,
-  0x1.c8f6d9406e733p-1, -0x1.a480p-46,
-  0x1.ca3405751c4dfp-1,  0x1.b000p-51,
-  0x1.cb720dcef9094p-1,  0x1.1400p-47,
-  0x1.ccb0f2e6d1689p-1,  0x1.0200p-48,
-  0x1.cdf0b555dc412p-1,  0x1.3600p-48,
-  0x1.cf3155b5bab3bp-1, -0x1.6900p-47,
-  0x1.d072d4a0789bcp-1,  0x1.9a00p-47,
-  0x1.d1b532b08c8fap-1, -0x1.5e00p-46,
-  0x1.d2f87080d8a85p-1,  0x1.d280p-46,
-  0x1.d43c8eacaa203p-1,  0x1.1a00p-47,
-  0x1.d5818dcfba491p-1,  0x1.f000p-50,
-  0x1.d6c76e862e6a1p-1, -0x1.3a00p-47,
-  0x1.d80e316c9834ep-1, -0x1.cd80p-47,
-  0x1.d955d71ff6090p-1,  0x1.4c00p-48,
-  0x1.da9e603db32aep-1,  0x1.f900p-48,
-  0x1.dbe7cd63a8325p-1,  0x1.9800p-49,
-  0x1.dd321f301b445p-1, -0x1.5200p-48,
-  0x1.de7d5641c05bfp-1, -0x1.d700p-46,
-  0x1.dfc97337b9aecp-1, -0x1.6140p-46,
-  0x1.e11676b197d5ep-1,  0x1.b480p-47,
-  0x1.e264614f5a3e7p-1,  0x1.0ce0p-43,
-  0x1.e3b333b16ee5cp-1,  0x1.c680p-47,
-  0x1.e502ee78b3fb4p-1, -0x1.9300p-47,
-  0x1.e653924676d68p-1, -0x1.5000p-49,
-  0x1.e7a51fbc74c44p-1, -0x1.7f80p-47,
-  0x1.e8f7977cdb726p-1, -0x1.3700p-48,
-  0x1.ea4afa2a490e8p-1,  0x1.5d00p-49,
-  0x1.eb9f4867ccae4p-1,  0x1.61a0p-46,
-  0x1.ecf482d8e680dp-1,  0x1.5500p-48,
-  0x1.ee4aaa2188514p-1,  0x1.6400p-51,
-  0x1.efa1bee615a13p-1, -0x1.e800p-49,
-  0x1.f0f9c1cb64106p-1, -0x1.a880p-48,
-  0x1.f252b376bb963p-1, -0x1.c900p-45,
-  0x1.f3ac948dd7275p-1,  0x1.a000p-53,
-  0x1.f50765b6e4524p-1, -0x1.4f00p-48,
-  0x1.f6632798844fdp-1,  0x1.a800p-51,
-  0x1.f7bfdad9cbe38p-1,  0x1.abc0p-48,
-  0x1.f91d802243c82p-1, -0x1.4600p-50,
-  0x1.fa7c1819e908ep-1, -0x1.b0c0p-47,
-  0x1.fbdba3692d511p-1, -0x1.0e00p-51,
-  0x1.fd3c22b8f7194p-1, -0x1.0de8p-46,
-  0x1.fe9d96b2a23eep-1,  0x1.e430p-49,
-  0x1.0000000000000p+0,  0x0.0000p+0,
-  0x1.00b1afa5abcbep+0, -0x1.3400p-52,
-  0x1.0163da9fb3303p+0, -0x1.2170p-46,
-  0x1.02168143b0282p+0,  0x1.a400p-52,
-  0x1.02c9a3e77806cp+0,  0x1.f980p-49,
-  0x1.037d42e11bbcap+0, -0x1.7400p-51,
-  0x1.04315e86e7f89p+0,  0x1.8300p-50,
-  0x1.04e5f72f65467p+0, -0x1.a3f0p-46,
-  0x1.059b0d315855ap+0, -0x1.2840p-47,
-  0x1.0650a0e3c1f95p+0,  0x1.1600p-48,
-  0x1.0706b29ddf71ap+0,  0x1.5240p-46,
-  0x1.07bd42b72a82dp+0, -0x1.9a00p-49,
-  0x1.0874518759bd0p+0,  0x1.6400p-49,
-  0x1.092bdf66607c8p+0, -0x1.0780p-47,
-  0x1.09e3ecac6f383p+0, -0x1.8000p-54,
-  0x1.0a9c79b1f3930p+0,  0x1.fa00p-48,
-  0x1.0b5586cf988fcp+0, -0x1.ac80p-48,
-  0x1.0c0f145e46c8ap+0,  0x1.9c00p-50,
-  0x1.0cc922b724816p+0,  0x1.5200p-47,
-  0x1.0d83b23395dd8p+0, -0x1.ad00p-48,
-  0x1.0e3ec32d3d1f3p+0,  0x1.bac0p-46,
-  0x1.0efa55fdfa9a6p+0, -0x1.4e80p-47,
-  0x1.0fb66affed2f0p+0, -0x1.d300p-47,
-  0x1.1073028d7234bp+0,  0x1.1500p-48,
-  0x1.11301d0125b5bp+0,  0x1.c000p-49,
-  0x1.11edbab5e2af9p+0,  0x1.6bc0p-46,
-  0x1.12abdc06c31d5p+0,  0x1.8400p-49,
-  0x1.136a814f2047dp+0, -0x1.ed00p-47,
-  0x1.1429aaea92de9p+0,  0x1.8e00p-49,
-  0x1.14e95934f3138p+0,  0x1.b400p-49,
-  0x1.15a98c8a58e71p+0,  0x1.5300p-47,
-  0x1.166a45471c3dfp+0,  0x1.3380p-47,
-  0x1.172b83c7d5211p+0,  0x1.8d40p-45,
-  0x1.17ed48695bb9fp+0, -0x1.5d00p-47,
-  0x1.18af9388c8d93p+0, -0x1.c880p-46,
-  0x1.1972658375d66p+0,  0x1.1f00p-46,
-  0x1.1a35beb6fcba7p+0,  0x1.0480p-46,
-  0x1.1af99f81387e3p+0, -0x1.7390p-43,
-  0x1.1bbe084045d54p+0,  0x1.4e40p-45,
-  0x1.1c82f95281c43p+0, -0x1.a200p-47,
-  0x1.1d4873168b9b2p+0,  0x1.3800p-49,
-  0x1.1e0e75eb44031p+0,  0x1.ac00p-49,
-  0x1.1ed5022fcd938p+0,  0x1.1900p-47,
-  0x1.1f9c18438cdf7p+0, -0x1.b780p-46,
-  0x1.2063b88628d8fp+0,  0x1.d940p-45,
-  0x1.212be3578a81ep+0,  0x1.8000p-50,
-  0x1.21f49917ddd41p+0,  0x1.b340p-45,
-  0x1.22bdda2791323p+0,  0x1.9f80p-46,
-  0x1.2387a6e7561e7p+0, -0x1.9c80p-46,
-  0x1.2451ffb821427p+0,  0x1.2300p-47,
-  0x1.251ce4fb2a602p+0, -0x1.3480p-46,
-  0x1.25e85711eceb0p+0,  0x1.2700p-46,
-  0x1.26b4565e27d16p+0,  0x1.1d00p-46,
-  0x1.2780e341de00fp+0,  0x1.1ee0p-44,
-  0x1.284dfe1f5633ep+0, -0x1.4c00p-46,
-  0x1.291ba7591bb30p+0, -0x1.3d80p-46,
-  0x1.29e9df51fdf09p+0,  0x1.8b00p-47,
-  0x1.2ab8a66d10e9bp+0, -0x1.27c0p-45,
-  0x1.2b87fd0dada3ap+0,  0x1.a340p-45,
-  0x1.2c57e39771af9p+0, -0x1.0800p-46,
-  0x1.2d285a6e402d9p+0, -0x1.ed00p-47,
-  0x1.2df961f641579p+0, -0x1.4200p-48,
-  0x1.2ecafa93e2ecfp+0, -0x1.4980p-45,
-  0x1.2f9d24abd8822p+0, -0x1.6300p-46,
-  0x1.306fe0a31b625p+0, -0x1.2360p-44,
-  0x1.31432edeea50bp+0, -0x1.0df8p-40,
-  0x1.32170fc4cd7b8p+0, -0x1.2480p-45,
-  0x1.32eb83ba8e9a2p+0, -0x1.5980p-45,
-  0x1.33c08b2641766p+0,  0x1.ed00p-46,
-  0x1.3496266e3fa27p+0, -0x1.c000p-50,
-  0x1.356c55f929f0fp+0, -0x1.0d80p-44,
-  0x1.36431a2de88b9p+0,  0x1.2c80p-45,
-  0x1.371a7373aaa39p+0,  0x1.0600p-45,
-  0x1.37f26231e74fep+0, -0x1.6600p-46,
-  0x1.38cae6d05d838p+0, -0x1.ae00p-47,
-  0x1.39a401b713ec3p+0, -0x1.4720p-43,
-  0x1.3a7db34e5a020p+0,  0x1.8200p-47,
-  0x1.3b57fbfec6e95p+0,  0x1.e800p-44,
-  0x1.3c32dc313a8f2p+0,  0x1.f800p-49,
-  0x1.3d0e544ede122p+0, -0x1.7a00p-46,
-  0x1.3dea64c1234bbp+0,  0x1.6300p-45,
-  0x1.3ec70df1c4eccp+0, -0x1.8a60p-43,
-  0x1.3fa4504ac7e8cp+0, -0x1.cdc0p-44,
-  0x1.40822c367a0bbp+0,  0x1.5b80p-45,
-  0x1.4160a21f72e95p+0,  0x1.ec00p-46,
-  0x1.423fb27094646p+0, -0x1.3600p-46,
-  0x1.431f5d950a920p+0,  0x1.3980p-45,
-  0x1.43ffa3f84b9ebp+0,  0x1.a000p-48,
-  0x1.44e0860618919p+0, -0x1.6c00p-48,
-  0x1.45c2042a7d201p+0, -0x1.bc00p-47,
-  0x1.46a41ed1d0016p+0, -0x1.2800p-46,
-  0x1.4786d668b3326p+0,  0x1.0e00p-44,
-  0x1.486a2b5c13c00p+0, -0x1.d400p-45,
-  0x1.494e1e192af04p+0,  0x1.c200p-47,
-  0x1.4a32af0d7d372p+0, -0x1.e500p-46,
-  0x1.4b17dea6db801p+0,  0x1.7800p-47,
-  0x1.4bfdad53629e1p+0, -0x1.3800p-46,
-  0x1.4ce41b817c132p+0,  0x1.0800p-47,
-  0x1.4dcb299fddddbp+0,  0x1.c700p-45,
-  0x1.4eb2d81d8ab96p+0, -0x1.ce00p-46,
-  0x1.4f9b2769d2d02p+0,  0x1.9200p-46,
-  0x1.508417f4531c1p+0, -0x1.8c00p-47,
-  0x1.516daa2cf662ap+0, -0x1.a000p-48,
-  0x1.5257de83f51eap+0,  0x1.a080p-43,
-  0x1.5342b569d4edap+0, -0x1.6d80p-45,
-  0x1.542e2f4f6ac1ap+0, -0x1.2440p-44,
-  0x1.551a4ca5d94dbp+0,  0x1.83c0p-43,
-  0x1.56070dde9116bp+0,  0x1.4b00p-45,
-  0x1.56f4736b529dep+0,  0x1.15a0p-43,
-  0x1.57e27dbe2c40ep+0, -0x1.9e00p-45,
-  0x1.58d12d497c76fp+0, -0x1.3080p-45,
-  0x1.59c0827ff0b4cp+0,  0x1.dec0p-43,
-  0x1.5ab07dd485427p+0, -0x1.4000p-51,
-  0x1.5ba11fba87af4p+0,  0x1.0080p-44,
-  0x1.5c9268a59460bp+0, -0x1.6c80p-45,
-  0x1.5d84590998e3fp+0,  0x1.69a0p-43,
-  0x1.5e76f15ad20e1p+0, -0x1.b400p-46,
-  0x1.5f6a320dcebcap+0,  0x1.7700p-46,
-  0x1.605e1b976dcb8p+0,  0x1.6f80p-45,
-  0x1.6152ae6cdf715p+0,  0x1.1000p-47,
-  0x1.6247eb03a5531p+0, -0x1.5d00p-46,
-  0x1.633dd1d1929b5p+0, -0x1.2d00p-46,
-  0x1.6434634ccc313p+0, -0x1.a800p-49,
-  0x1.652b9febc8efap+0, -0x1.8600p-45,
-  0x1.6623882553397p+0,  0x1.1fe0p-40,
-  0x1.671c1c708328ep+0, -0x1.7200p-44,
-  0x1.68155d44ca97ep+0,  0x1.6800p-49,
-  0x1.690f4b19e9471p+0, -0x1.9780p-45,
-};
-
-/*
- * exp2(x): compute the base 2 exponential of x
- *
- * Accuracy: Peak error < 0.503 ulp for normalized results.
- *
- * Method: (accurate tables)
- *
- *   Reduce x:
- *     x = k + y, for integer k and |y| <= 1/2.
- *     Thus we have exp2(x) = 2**k * exp2(y).
- *
- *   Reduce y:
- *     y = i/TBLSIZE + z - eps[i] for integer i near y * TBLSIZE.
- *     Thus we have exp2(y) = exp2(i/TBLSIZE) * exp2(z - eps[i]),
- *     with |z - eps[i]| <= 2**-9 + 2**-39 for the table used.
- *
- *   We compute exp2(i/TBLSIZE) via table lookup and exp2(z - eps[i]) via
- *   a degree-5 minimax polynomial with maximum error under 1.3 * 2**-61.
- *   The values in exp2t[] and eps[] are chosen such that
- *   exp2t[i] = exp2(i/TBLSIZE + eps[i]), and eps[i] is a small offset such
- *   that exp2t[i] is accurate to 2**-64.
- *
- *   Note that the range of i is +-TBLSIZE/2, so we actually index the tables
- *   by i0 = i + TBLSIZE/2.  For cache efficiency, exp2t[] and eps[] are
- *   virtual tables, interleaved in the real table tbl[].
- *
- *   This method is due to Gal, with many details due to Gal and Bachelis:
- *
- *      Gal, S. and Bachelis, B.  An Accurate Elementary Mathematical Library
- *      for the IEEE Floating Point Standard.  TOMS 17(1), 26-46 (1991).
- */
-double exp2(double x)
-{
-	double_t r, t, z;
-	uint32_t ix, i0;
-	union {double f; uint64_t i;} u = {x};
-	union {uint32_t u; int32_t i;} k;
-
-	/* Filter out exceptional cases. */
-	ix = u.i>>32 & 0x7fffffff;
-	if (ix >= 0x408ff000) {  /* |x| >= 1022 or nan */
-		if (ix >= 0x40900000 && u.i>>63 == 0) {  /* x >= 1024 or nan */
-			/* overflow */
-			x *= 0x1p1023;
-			return x;
-		}
-		if (ix >= 0x7ff00000)  /* -inf or -nan */
-			return -1/x;
-		if (u.i>>63) {  /* x <= -1022 */
-			/* underflow */
-			if (x <= -1075 || x - 0x1p52 + 0x1p52 != x)
-				FORCE_EVAL((float)(-0x1p-149/x));
-			if (x <= -1075)
-				return 0;
-		}
-	} else if (ix < 0x3c900000) {  /* |x| < 0x1p-54 */
-		return 1.0 + x;
-	}
-
-	/* Reduce x, computing z, i0, and k. */
-	u.f = x + redux;
-	i0 = u.i;
-	i0 += TBLSIZE / 2;
-	k.u = i0 / TBLSIZE * TBLSIZE;
-	k.i /= TBLSIZE;
-	i0 %= TBLSIZE;
-	u.f -= redux;
-	z = x - u.f;
-
-	/* Compute r = exp2(y) = exp2t[i0] * p(z - eps[i]). */
-	t = tbl[2*i0];       /* exp2t[i0] */
-	z -= tbl[2*i0 + 1];  /* eps[i0]   */
-	r = t + t * z * (P1 + z * (P2 + z * (P3 + z * (P4 + z * P5))));
-
-	return scalbn(r, k.i);
-}
diff --git a/libc/src/musl/math/exp2f.c b/libc/src/musl/math/exp2f.c
deleted file mode 100644
index cf6126e..0000000
--- a/libc/src/musl/math/exp2f.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_exp2f.c */
-/*-
- * Copyright (c) 2005 David Schultz <das@FreeBSD.ORG>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "libm.h"
-
-#define TBLSIZE 16
-
-static const float
-redux = 0x1.8p23f / TBLSIZE,
-P1    = 0x1.62e430p-1f,
-P2    = 0x1.ebfbe0p-3f,
-P3    = 0x1.c6b348p-5f,
-P4    = 0x1.3b2c9cp-7f;
-
-static const double exp2ft[TBLSIZE] = {
-  0x1.6a09e667f3bcdp-1,
-  0x1.7a11473eb0187p-1,
-  0x1.8ace5422aa0dbp-1,
-  0x1.9c49182a3f090p-1,
-  0x1.ae89f995ad3adp-1,
-  0x1.c199bdd85529cp-1,
-  0x1.d5818dcfba487p-1,
-  0x1.ea4afa2a490dap-1,
-  0x1.0000000000000p+0,
-  0x1.0b5586cf9890fp+0,
-  0x1.172b83c7d517bp+0,
-  0x1.2387a6e756238p+0,
-  0x1.306fe0a31b715p+0,
-  0x1.3dea64c123422p+0,
-  0x1.4bfdad5362a27p+0,
-  0x1.5ab07dd485429p+0,
-};
-
-/*
- * exp2f(x): compute the base 2 exponential of x
- *
- * Accuracy: Peak error < 0.501 ulp; location of peak: -0.030110927.
- *
- * Method: (equally-spaced tables)
- *
- *   Reduce x:
- *     x = k + y, for integer k and |y| <= 1/2.
- *     Thus we have exp2f(x) = 2**k * exp2(y).
- *
- *   Reduce y:
- *     y = i/TBLSIZE + z for integer i near y * TBLSIZE.
- *     Thus we have exp2(y) = exp2(i/TBLSIZE) * exp2(z),
- *     with |z| <= 2**-(TBLSIZE+1).
- *
- *   We compute exp2(i/TBLSIZE) via table lookup and exp2(z) via a
- *   degree-4 minimax polynomial with maximum error under 1.4 * 2**-33.
- *   Using double precision for everything except the reduction makes
- *   roundoff error insignificant and simplifies the scaling step.
- *
- *   This method is due to Tang, but I do not use his suggested parameters:
- *
- *      Tang, P.  Table-driven Implementation of the Exponential Function
- *      in IEEE Floating-Point Arithmetic.  TOMS 15(2), 144-157 (1989).
- */
-float exp2f(float x)
-{
-	double_t t, r, z;
-	union {float f; uint32_t i;} u = {x};
-	union {double f; uint64_t i;} uk;
-	uint32_t ix, i0, k;
-
-	/* Filter out exceptional cases. */
-	ix = u.i & 0x7fffffff;
-	if (ix > 0x42fc0000) {  /* |x| > 126 */
-		if (u.i >= 0x43000000 && u.i < 0x80000000) {  /* x >= 128 */
-			x *= 0x1p127f;
-			return x;
-		}
-		if (u.i >= 0x80000000) {  /* x < -126 */
-			if (u.i >= 0xc3160000 || (u.i & 0x0000ffff))
-				FORCE_EVAL(-0x1p-149f/x);
-			if (u.i >= 0xc3160000)  /* x <= -150 */
-				return 0;
-		}
-	} else if (ix <= 0x33000000) {  /* |x| <= 0x1p-25 */
-		return 1.0f + x;
-	}
-
-	/* Reduce x, computing z, i0, and k. */
-	u.f = x + redux;
-	i0 = u.i;
-	i0 += TBLSIZE / 2;
-	k = i0 / TBLSIZE;
-	uk.i = (uint64_t)(0x3ff + k)<<52;
-	i0 &= TBLSIZE - 1;
-	u.f -= redux;
-	z = x - u.f;
-	/* Compute r = exp2(y) = exp2ft[i0] * p(z). */
-	r = exp2ft[i0];
-	t = r * z;
-	r = r + t * (P1 + z * P2) + t * (z * z) * (P3 + z * P4);
-
-	/* Scale by 2**k */
-	return r * uk.f;
-}
diff --git a/libc/src/musl/math/exp2l.c b/libc/src/musl/math/exp2l.c
deleted file mode 100644
index 3565c1e..0000000
--- a/libc/src/musl/math/exp2l.c
+++ /dev/null
@@ -1,619 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/ld80/s_exp2l.c and /usr/src/lib/msun/ld128/s_exp2l.c */
-/*-
- * Copyright (c) 2005-2008 David Schultz <das@FreeBSD.ORG>
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double exp2l(long double x)
-{
-	return exp2(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-#define TBLBITS 7
-#define TBLSIZE (1 << TBLBITS)
-
-static const double
-redux = 0x1.8p63 / TBLSIZE,
-P1    = 0x1.62e42fefa39efp-1,
-P2    = 0x1.ebfbdff82c58fp-3,
-P3    = 0x1.c6b08d7049fap-5,
-P4    = 0x1.3b2ab6fba4da5p-7,
-P5    = 0x1.5d8804780a736p-10,
-P6    = 0x1.430918835e33dp-13;
-
-static const double tbl[TBLSIZE * 2] = {
-	0x1.6a09e667f3bcdp-1,   -0x1.bdd3413b2648p-55,
-	0x1.6c012750bdabfp-1,   -0x1.2895667ff0cp-57,
-	0x1.6dfb23c651a2fp-1,   -0x1.bbe3a683c88p-58,
-	0x1.6ff7df9519484p-1,   -0x1.83c0f25860fp-56,
-	0x1.71f75e8ec5f74p-1,   -0x1.16e4786887bp-56,
-	0x1.73f9a48a58174p-1,   -0x1.0a8d96c65d5p-55,
-	0x1.75feb564267c9p-1,   -0x1.0245957316ep-55,
-	0x1.780694fde5d3fp-1,    0x1.866b80a0216p-55,
-	0x1.7a11473eb0187p-1,   -0x1.41577ee0499p-56,
-	0x1.7c1ed0130c132p-1,    0x1.f124cd1164ep-55,
-	0x1.7e2f336cf4e62p-1,    0x1.05d02ba157ap-57,
-	0x1.80427543e1a12p-1,   -0x1.27c86626d97p-55,
-	0x1.82589994cce13p-1,   -0x1.d4c1dd41533p-55,
-	0x1.8471a4623c7adp-1,   -0x1.8d684a341cep-56,
-	0x1.868d99b4492edp-1,   -0x1.fc6f89bd4f68p-55,
-	0x1.88ac7d98a6699p-1,    0x1.994c2f37cb5p-55,
-	0x1.8ace5422aa0dbp-1,    0x1.6e9f156864bp-55,
-	0x1.8cf3216b5448cp-1,   -0x1.0d55e32e9e4p-57,
-	0x1.8f1ae99157736p-1,    0x1.5cc13a2e397p-56,
-	0x1.9145b0b91ffc6p-1,   -0x1.dd6792e5825p-55,
-	0x1.93737b0cdc5e5p-1,   -0x1.75fc781b58p-58,
-	0x1.95a44cbc8520fp-1,   -0x1.64b7c96a5fp-57,
-	0x1.97d829fde4e5p-1,    -0x1.d185b7c1b86p-55,
-	0x1.9a0f170ca07bap-1,   -0x1.173bd91cee6p-55,
-	0x1.9c49182a3f09p-1,     0x1.c7c46b071f2p-57,
-	0x1.9e86319e32323p-1,    0x1.824ca78e64cp-57,
-	0x1.a0c667b5de565p-1,   -0x1.359495d1cd5p-55,
-	0x1.a309bec4a2d33p-1,    0x1.6305c7ddc368p-55,
-	0x1.a5503b23e255dp-1,   -0x1.d2f6edb8d42p-55,
-	0x1.a799e1330b358p-1,    0x1.bcb7ecac564p-55,
-	0x1.a9e6b5579fdbfp-1,    0x1.0fac90ef7fdp-55,
-	0x1.ac36bbfd3f37ap-1,   -0x1.f9234cae76dp-56,
-	0x1.ae89f995ad3adp-1,    0x1.7a1cd345dcc8p-55,
-	0x1.b0e07298db666p-1,   -0x1.bdef54c80e4p-55,
-	0x1.b33a2b84f15fbp-1,   -0x1.2805e3084d8p-58,
-	0x1.b59728de5593ap-1,   -0x1.c71dfbbba6ep-55,
-	0x1.b7f76f2fb5e47p-1,   -0x1.5584f7e54acp-57,
-	0x1.ba5b030a1064ap-1,   -0x1.efcd30e5429p-55,
-	0x1.bcc1e904bc1d2p-1,    0x1.23dd07a2d9fp-56,
-	0x1.bf2c25bd71e09p-1,   -0x1.efdca3f6b9c8p-55,
-	0x1.c199bdd85529cp-1,    0x1.11065895049p-56,
-	0x1.c40ab5fffd07ap-1,    0x1.b4537e083c6p-55,
-	0x1.c67f12e57d14bp-1,    0x1.2884dff483c8p-55,
-	0x1.c8f6d9406e7b5p-1,    0x1.1acbc48805cp-57,
-	0x1.cb720dcef9069p-1,    0x1.503cbd1e94ap-57,
-	0x1.cdf0b555dc3fap-1,   -0x1.dd83b53829dp-56,
-	0x1.d072d4a07897cp-1,   -0x1.cbc3743797a8p-55,
-	0x1.d2f87080d89f2p-1,   -0x1.d487b719d858p-55,
-	0x1.d5818dcfba487p-1,    0x1.2ed02d75b37p-56,
-	0x1.d80e316c98398p-1,   -0x1.11ec18bedep-55,
-	0x1.da9e603db3285p-1,    0x1.c2300696db5p-55,
-	0x1.dd321f301b46p-1,     0x1.2da5778f019p-55,
-	0x1.dfc97337b9b5fp-1,   -0x1.1a5cd4f184b8p-55,
-	0x1.e264614f5a129p-1,   -0x1.7b627817a148p-55,
-	0x1.e502ee78b3ff6p-1,    0x1.39e8980a9cdp-56,
-	0x1.e7a51fbc74c83p-1,    0x1.2d522ca0c8ep-55,
-	0x1.ea4afa2a490dap-1,   -0x1.e9c23179c288p-55,
-	0x1.ecf482d8e67f1p-1,   -0x1.c93f3b411ad8p-55,
-	0x1.efa1bee615a27p-1,    0x1.dc7f486a4b68p-55,
-	0x1.f252b376bba97p-1,    0x1.3a1a5bf0d8e8p-55,
-	0x1.f50765b6e454p-1,     0x1.9d3e12dd8a18p-55,
-	0x1.f7bfdad9cbe14p-1,   -0x1.dbb12d00635p-55,
-	0x1.fa7c1819e90d8p-1,    0x1.74853f3a593p-56,
-	0x1.fd3c22b8f71f1p-1,    0x1.2eb74966578p-58,
-	0x1p+0,                  0x0p+0,
-	0x1.0163da9fb3335p+0,    0x1.b61299ab8cd8p-54,
-	0x1.02c9a3e778061p+0,   -0x1.19083535b08p-56,
-	0x1.04315e86e7f85p+0,   -0x1.0a31c1977c98p-54,
-	0x1.059b0d3158574p+0,    0x1.d73e2a475b4p-55,
-	0x1.0706b29ddf6dep+0,   -0x1.c91dfe2b13cp-55,
-	0x1.0874518759bc8p+0,    0x1.186be4bb284p-57,
-	0x1.09e3ecac6f383p+0,    0x1.14878183161p-54,
-	0x1.0b5586cf9890fp+0,    0x1.8a62e4adc61p-54,
-	0x1.0cc922b7247f7p+0,    0x1.01edc16e24f8p-54,
-	0x1.0e3ec32d3d1a2p+0,    0x1.03a1727c58p-59,
-	0x1.0fb66affed31bp+0,   -0x1.b9bedc44ebcp-57,
-	0x1.11301d0125b51p+0,   -0x1.6c51039449bp-54,
-	0x1.12abdc06c31ccp+0,   -0x1.1b514b36ca8p-58,
-	0x1.1429aaea92dep+0,    -0x1.32fbf9af1368p-54,
-	0x1.15a98c8a58e51p+0,    0x1.2406ab9eeabp-55,
-	0x1.172b83c7d517bp+0,   -0x1.19041b9d78ap-55,
-	0x1.18af9388c8deap+0,   -0x1.11023d1970f8p-54,
-	0x1.1a35beb6fcb75p+0,    0x1.e5b4c7b4969p-55,
-	0x1.1bbe084045cd4p+0,   -0x1.95386352ef6p-54,
-	0x1.1d4873168b9aap+0,    0x1.e016e00a264p-54,
-	0x1.1ed5022fcd91dp+0,   -0x1.1df98027bb78p-54,
-	0x1.2063b88628cd6p+0,    0x1.dc775814a85p-55,
-	0x1.21f49917ddc96p+0,    0x1.2a97e9494a6p-55,
-	0x1.2387a6e756238p+0,    0x1.9b07eb6c7058p-54,
-	0x1.251ce4fb2a63fp+0,    0x1.ac155bef4f5p-55,
-	0x1.26b4565e27cddp+0,    0x1.2bd339940eap-55,
-	0x1.284dfe1f56381p+0,   -0x1.a4c3a8c3f0d8p-54,
-	0x1.29e9df51fdee1p+0,    0x1.612e8afad12p-55,
-	0x1.2b87fd0dad99p+0,    -0x1.10adcd6382p-59,
-	0x1.2d285a6e4030bp+0,    0x1.0024754db42p-54,
-	0x1.2ecafa93e2f56p+0,    0x1.1ca0f45d524p-56,
-	0x1.306fe0a31b715p+0,    0x1.6f46ad23183p-55,
-	0x1.32170fc4cd831p+0,    0x1.a9ce78e1804p-55,
-	0x1.33c08b26416ffp+0,    0x1.327218436598p-54,
-	0x1.356c55f929ff1p+0,   -0x1.b5cee5c4e46p-55,
-	0x1.371a7373aa9cbp+0,   -0x1.63aeabf42ebp-54,
-	0x1.38cae6d05d866p+0,   -0x1.e958d3c99048p-54,
-	0x1.3a7db34e59ff7p+0,   -0x1.5e436d661f6p-56,
-	0x1.3c32dc313a8e5p+0,   -0x1.efff8375d2ap-54,
-	0x1.3dea64c123422p+0,    0x1.ada0911f09fp-55,
-	0x1.3fa4504ac801cp+0,   -0x1.7d023f956fap-54,
-	0x1.4160a21f72e2ap+0,   -0x1.ef3691c309p-58,
-	0x1.431f5d950a897p+0,   -0x1.1c7dde35f7ap-55,
-	0x1.44e086061892dp+0,    0x1.89b7a04ef8p-59,
-	0x1.46a41ed1d0057p+0,    0x1.c944bd1648a8p-54,
-	0x1.486a2b5c13cdp+0,     0x1.3c1a3b69062p-56,
-	0x1.4a32af0d7d3dep+0,    0x1.9cb62f3d1be8p-54,
-	0x1.4bfdad5362a27p+0,    0x1.d4397afec42p-56,
-	0x1.4dcb299fddd0dp+0,    0x1.8ecdbbc6a78p-54,
-	0x1.4f9b2769d2ca7p+0,   -0x1.4b309d25958p-54,
-	0x1.516daa2cf6642p+0,   -0x1.f768569bd94p-55,
-	0x1.5342b569d4f82p+0,   -0x1.07abe1db13dp-55,
-	0x1.551a4ca5d920fp+0,   -0x1.d689cefede6p-55,
-	0x1.56f4736b527dap+0,    0x1.9bb2c011d938p-54,
-	0x1.58d12d497c7fdp+0,    0x1.295e15b9a1ep-55,
-	0x1.5ab07dd485429p+0,    0x1.6324c0546478p-54,
-	0x1.5c9268a5946b7p+0,    0x1.c4b1b81698p-60,
-	0x1.5e76f15ad2148p+0,    0x1.ba6f93080e68p-54,
-	0x1.605e1b976dc09p+0,   -0x1.3e2429b56de8p-54,
-	0x1.6247eb03a5585p+0,   -0x1.383c17e40b48p-54,
-	0x1.6434634ccc32p+0,    -0x1.c483c759d89p-55,
-	0x1.6623882552225p+0,   -0x1.bb60987591cp-54,
-	0x1.68155d44ca973p+0,    0x1.038ae44f74p-57,
-};
-
-/*
- * exp2l(x): compute the base 2 exponential of x
- *
- * Accuracy: Peak error < 0.511 ulp.
- *
- * Method: (equally-spaced tables)
- *
- *   Reduce x:
- *     x = 2**k + y, for integer k and |y| <= 1/2.
- *     Thus we have exp2l(x) = 2**k * exp2(y).
- *
- *   Reduce y:
- *     y = i/TBLSIZE + z for integer i near y * TBLSIZE.
- *     Thus we have exp2(y) = exp2(i/TBLSIZE) * exp2(z),
- *     with |z| <= 2**-(TBLBITS+1).
- *
- *   We compute exp2(i/TBLSIZE) via table lookup and exp2(z) via a
- *   degree-6 minimax polynomial with maximum error under 2**-69.
- *   The table entries each have 104 bits of accuracy, encoded as
- *   a pair of double precision values.
- */
-long double exp2l(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	long double r, z;
-	uint32_t i0;
-	union {uint32_t u; int32_t i;} k;
-
-	/* Filter out exceptional cases. */
-	if (e >= 0x3fff + 13) {  /* |x| >= 8192 or x is NaN */
-		if (u.i.se >= 0x3fff + 14 && u.i.se >> 15 == 0)
-			/* overflow */
-			return x * 0x1p16383L;
-		if (e == 0x7fff)  /* -inf or -nan */
-			return -1/x;
-		if (x < -16382) {
-			if (x <= -16446 || x - 0x1p63 + 0x1p63 != x)
-				/* underflow */
-				FORCE_EVAL((float)(-0x1p-149/x));
-			if (x <= -16446)
-				return 0;
-		}
-	} else if (e < 0x3fff - 64) {
-		return 1 + x;
-	}
-
-	/*
-	 * Reduce x, computing z, i0, and k. The low bits of x + redux
-	 * contain the 16-bit integer part of the exponent (k) followed by
-	 * TBLBITS fractional bits (i0). We use bit tricks to extract these
-	 * as integers, then set z to the remainder.
-	 *
-	 * Example: Suppose x is 0xabc.123456p0 and TBLBITS is 8.
-	 * Then the low-order word of x + redux is 0x000abc12,
-	 * We split this into k = 0xabc and i0 = 0x12 (adjusted to
-	 * index into the table), then we compute z = 0x0.003456p0.
-	 */
-	u.f = x + redux;
-	i0 = u.i.m + TBLSIZE / 2;
-	k.u = i0 / TBLSIZE * TBLSIZE;
-	k.i /= TBLSIZE;
-	i0 %= TBLSIZE;
-	u.f -= redux;
-	z = x - u.f;
-
-	/* Compute r = exp2l(y) = exp2lt[i0] * p(z). */
-	long double t_hi = tbl[2*i0];
-	long double t_lo = tbl[2*i0 + 1];
-	/* XXX This gives > 1 ulp errors outside of FE_TONEAREST mode */
-	r = t_lo + (t_hi + t_lo) * z * (P1 + z * (P2 + z * (P3 + z * (P4
-	     + z * (P5 + z * P6))))) + t_hi;
-
-	return scalbnl(r, k.i);
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-#define TBLBITS 7
-#define TBLSIZE (1 << TBLBITS)
-
-static const long double
-    P1        = 0x1.62e42fefa39ef35793c7673007e6p-1L,
-    P2        = 0x1.ebfbdff82c58ea86f16b06ec9736p-3L,
-    P3        = 0x1.c6b08d704a0bf8b33a762bad3459p-5L,
-    P4        = 0x1.3b2ab6fba4e7729ccbbe0b4f3fc2p-7L,
-    P5        = 0x1.5d87fe78a67311071dee13fd11d9p-10L,
-    P6        = 0x1.430912f86c7876f4b663b23c5fe5p-13L;
-
-static const double
-    P7        = 0x1.ffcbfc588b041p-17,
-    P8        = 0x1.62c0223a5c7c7p-20,
-    P9        = 0x1.b52541ff59713p-24,
-    P10       = 0x1.e4cf56a391e22p-28,
-    redux     = 0x1.8p112 / TBLSIZE;
-
-static const long double tbl[TBLSIZE] = {
-	0x1.6a09e667f3bcc908b2fb1366dfeap-1L,
-	0x1.6c012750bdabeed76a99800f4edep-1L,
-	0x1.6dfb23c651a2ef220e2cbe1bc0d4p-1L,
-	0x1.6ff7df9519483cf87e1b4f3e1e98p-1L,
-	0x1.71f75e8ec5f73dd2370f2ef0b148p-1L,
-	0x1.73f9a48a58173bd5c9a4e68ab074p-1L,
-	0x1.75feb564267c8bf6e9aa33a489a8p-1L,
-	0x1.780694fde5d3f619ae02808592a4p-1L,
-	0x1.7a11473eb0186d7d51023f6ccb1ap-1L,
-	0x1.7c1ed0130c1327c49334459378dep-1L,
-	0x1.7e2f336cf4e62105d02ba1579756p-1L,
-	0x1.80427543e1a11b60de67649a3842p-1L,
-	0x1.82589994cce128acf88afab34928p-1L,
-	0x1.8471a4623c7acce52f6b97c6444cp-1L,
-	0x1.868d99b4492ec80e41d90ac2556ap-1L,
-	0x1.88ac7d98a669966530bcdf2d4cc0p-1L,
-	0x1.8ace5422aa0db5ba7c55a192c648p-1L,
-	0x1.8cf3216b5448bef2aa1cd161c57ap-1L,
-	0x1.8f1ae991577362b982745c72eddap-1L,
-	0x1.9145b0b91ffc588a61b469f6b6a0p-1L,
-	0x1.93737b0cdc5e4f4501c3f2540ae8p-1L,
-	0x1.95a44cbc8520ee9b483695a0e7fep-1L,
-	0x1.97d829fde4e4f8b9e920f91e8eb6p-1L,
-	0x1.9a0f170ca07b9ba3109b8c467844p-1L,
-	0x1.9c49182a3f0901c7c46b071f28dep-1L,
-	0x1.9e86319e323231824ca78e64c462p-1L,
-	0x1.a0c667b5de564b29ada8b8cabbacp-1L,
-	0x1.a309bec4a2d3358c171f770db1f4p-1L,
-	0x1.a5503b23e255c8b424491caf88ccp-1L,
-	0x1.a799e1330b3586f2dfb2b158f31ep-1L,
-	0x1.a9e6b5579fdbf43eb243bdff53a2p-1L,
-	0x1.ac36bbfd3f379c0db966a3126988p-1L,
-	0x1.ae89f995ad3ad5e8734d17731c80p-1L,
-	0x1.b0e07298db66590842acdfc6fb4ep-1L,
-	0x1.b33a2b84f15faf6bfd0e7bd941b0p-1L,
-	0x1.b59728de559398e3881111648738p-1L,
-	0x1.b7f76f2fb5e46eaa7b081ab53ff6p-1L,
-	0x1.ba5b030a10649840cb3c6af5b74cp-1L,
-	0x1.bcc1e904bc1d2247ba0f45b3d06cp-1L,
-	0x1.bf2c25bd71e088408d7025190cd0p-1L,
-	0x1.c199bdd85529c2220cb12a0916bap-1L,
-	0x1.c40ab5fffd07a6d14df820f17deap-1L,
-	0x1.c67f12e57d14b4a2137fd20f2a26p-1L,
-	0x1.c8f6d9406e7b511acbc48805c3f6p-1L,
-	0x1.cb720dcef90691503cbd1e949d0ap-1L,
-	0x1.cdf0b555dc3f9c44f8958fac4f12p-1L,
-	0x1.d072d4a07897b8d0f22f21a13792p-1L,
-	0x1.d2f87080d89f18ade123989ea50ep-1L,
-	0x1.d5818dcfba48725da05aeb66dff8p-1L,
-	0x1.d80e316c98397bb84f9d048807a0p-1L,
-	0x1.da9e603db3285708c01a5b6d480cp-1L,
-	0x1.dd321f301b4604b695de3c0630c0p-1L,
-	0x1.dfc97337b9b5eb968cac39ed284cp-1L,
-	0x1.e264614f5a128a12761fa17adc74p-1L,
-	0x1.e502ee78b3ff6273d130153992d0p-1L,
-	0x1.e7a51fbc74c834b548b2832378a4p-1L,
-	0x1.ea4afa2a490d9858f73a18f5dab4p-1L,
-	0x1.ecf482d8e67f08db0312fb949d50p-1L,
-	0x1.efa1bee615a27771fd21a92dabb6p-1L,
-	0x1.f252b376bba974e8696fc3638f24p-1L,
-	0x1.f50765b6e4540674f84b762861a6p-1L,
-	0x1.f7bfdad9cbe138913b4bfe72bd78p-1L,
-	0x1.fa7c1819e90d82e90a7e74b26360p-1L,
-	0x1.fd3c22b8f71f10975ba4b32bd006p-1L,
-	0x1.0000000000000000000000000000p+0L,
-	0x1.0163da9fb33356d84a66ae336e98p+0L,
-	0x1.02c9a3e778060ee6f7caca4f7a18p+0L,
-	0x1.04315e86e7f84bd738f9a20da442p+0L,
-	0x1.059b0d31585743ae7c548eb68c6ap+0L,
-	0x1.0706b29ddf6ddc6dc403a9d87b1ep+0L,
-	0x1.0874518759bc808c35f25d942856p+0L,
-	0x1.09e3ecac6f3834521e060c584d5cp+0L,
-	0x1.0b5586cf9890f6298b92b7184200p+0L,
-	0x1.0cc922b7247f7407b705b893dbdep+0L,
-	0x1.0e3ec32d3d1a2020742e4f8af794p+0L,
-	0x1.0fb66affed31af232091dd8a169ep+0L,
-	0x1.11301d0125b50a4ebbf1aed9321cp+0L,
-	0x1.12abdc06c31cbfb92bad324d6f84p+0L,
-	0x1.1429aaea92ddfb34101943b2588ep+0L,
-	0x1.15a98c8a58e512480d573dd562aep+0L,
-	0x1.172b83c7d517adcdf7c8c50eb162p+0L,
-	0x1.18af9388c8de9bbbf70b9a3c269cp+0L,
-	0x1.1a35beb6fcb753cb698f692d2038p+0L,
-	0x1.1bbe084045cd39ab1e72b442810ep+0L,
-	0x1.1d4873168b9aa7805b8028990be8p+0L,
-	0x1.1ed5022fcd91cb8819ff61121fbep+0L,
-	0x1.2063b88628cd63b8eeb0295093f6p+0L,
-	0x1.21f49917ddc962552fd29294bc20p+0L,
-	0x1.2387a6e75623866c1fadb1c159c0p+0L,
-	0x1.251ce4fb2a63f3582ab7de9e9562p+0L,
-	0x1.26b4565e27cdd257a673281d3068p+0L,
-	0x1.284dfe1f5638096cf15cf03c9fa0p+0L,
-	0x1.29e9df51fdee12c25d15f5a25022p+0L,
-	0x1.2b87fd0dad98ffddea46538fca24p+0L,
-	0x1.2d285a6e4030b40091d536d0733ep+0L,
-	0x1.2ecafa93e2f5611ca0f45d5239a4p+0L,
-	0x1.306fe0a31b7152de8d5a463063bep+0L,
-	0x1.32170fc4cd8313539cf1c3009330p+0L,
-	0x1.33c08b26416ff4c9c8610d96680ep+0L,
-	0x1.356c55f929ff0c94623476373be4p+0L,
-	0x1.371a7373aa9caa7145502f45452ap+0L,
-	0x1.38cae6d05d86585a9cb0d9bed530p+0L,
-	0x1.3a7db34e59ff6ea1bc9299e0a1fep+0L,
-	0x1.3c32dc313a8e484001f228b58cf0p+0L,
-	0x1.3dea64c12342235b41223e13d7eep+0L,
-	0x1.3fa4504ac801ba0bf701aa417b9cp+0L,
-	0x1.4160a21f72e29f84325b8f3dbacap+0L,
-	0x1.431f5d950a896dc704439410b628p+0L,
-	0x1.44e086061892d03136f409df0724p+0L,
-	0x1.46a41ed1d005772512f459229f0ap+0L,
-	0x1.486a2b5c13cd013c1a3b69062f26p+0L,
-	0x1.4a32af0d7d3de672d8bcf46f99b4p+0L,
-	0x1.4bfdad5362a271d4397afec42e36p+0L,
-	0x1.4dcb299fddd0d63b36ef1a9e19dep+0L,
-	0x1.4f9b2769d2ca6ad33d8b69aa0b8cp+0L,
-	0x1.516daa2cf6641c112f52c84d6066p+0L,
-	0x1.5342b569d4f81df0a83c49d86bf4p+0L,
-	0x1.551a4ca5d920ec52ec620243540cp+0L,
-	0x1.56f4736b527da66ecb004764e61ep+0L,
-	0x1.58d12d497c7fd252bc2b7343d554p+0L,
-	0x1.5ab07dd48542958c93015191e9a8p+0L,
-	0x1.5c9268a5946b701c4b1b81697ed4p+0L,
-	0x1.5e76f15ad21486e9be4c20399d12p+0L,
-	0x1.605e1b976dc08b076f592a487066p+0L,
-	0x1.6247eb03a5584b1f0fa06fd2d9eap+0L,
-	0x1.6434634ccc31fc76f8714c4ee122p+0L,
-	0x1.66238825522249127d9e29b92ea2p+0L,
-	0x1.68155d44ca973081c57227b9f69ep+0L,
-};
-
-static const float eps[TBLSIZE] = {
-	-0x1.5c50p-101,
-	-0x1.5d00p-106,
-	 0x1.8e90p-102,
-	-0x1.5340p-103,
-	 0x1.1bd0p-102,
-	-0x1.4600p-105,
-	-0x1.7a40p-104,
-	 0x1.d590p-102,
-	-0x1.d590p-101,
-	 0x1.b100p-103,
-	-0x1.0d80p-105,
-	 0x1.6b00p-103,
-	-0x1.9f00p-105,
-	 0x1.c400p-103,
-	 0x1.e120p-103,
-	-0x1.c100p-104,
-	-0x1.9d20p-103,
-	 0x1.a800p-108,
-	 0x1.4c00p-106,
-	-0x1.9500p-106,
-	 0x1.6900p-105,
-	-0x1.29d0p-100,
-	 0x1.4c60p-103,
-	 0x1.13a0p-102,
-	-0x1.5b60p-103,
-	-0x1.1c40p-103,
-	 0x1.db80p-102,
-	 0x1.91a0p-102,
-	 0x1.dc00p-105,
-	 0x1.44c0p-104,
-	 0x1.9710p-102,
-	 0x1.8760p-103,
-	-0x1.a720p-103,
-	 0x1.ed20p-103,
-	-0x1.49c0p-102,
-	-0x1.e000p-111,
-	 0x1.86a0p-103,
-	 0x1.2b40p-103,
-	-0x1.b400p-108,
-	 0x1.1280p-99,
-	-0x1.02d8p-102,
-	-0x1.e3d0p-103,
-	-0x1.b080p-105,
-	-0x1.f100p-107,
-	-0x1.16c0p-105,
-	-0x1.1190p-103,
-	-0x1.a7d2p-100,
-	 0x1.3450p-103,
-	-0x1.67c0p-105,
-	 0x1.4b80p-104,
-	-0x1.c4e0p-103,
-	 0x1.6000p-108,
-	-0x1.3f60p-105,
-	 0x1.93f0p-104,
-	 0x1.5fe0p-105,
-	 0x1.6f80p-107,
-	-0x1.7600p-106,
-	 0x1.21e0p-106,
-	-0x1.3a40p-106,
-	-0x1.40c0p-104,
-	-0x1.9860p-105,
-	-0x1.5d40p-108,
-	-0x1.1d70p-106,
-	 0x1.2760p-105,
-	 0x0.0000p+0,
-	 0x1.21e2p-104,
-	-0x1.9520p-108,
-	-0x1.5720p-106,
-	-0x1.4810p-106,
-	-0x1.be00p-109,
-	 0x1.0080p-105,
-	-0x1.5780p-108,
-	-0x1.d460p-105,
-	-0x1.6140p-105,
-	 0x1.4630p-104,
-	 0x1.ad50p-103,
-	 0x1.82e0p-105,
-	 0x1.1d3cp-101,
-	 0x1.6100p-107,
-	 0x1.ec30p-104,
-	 0x1.f200p-108,
-	 0x1.0b40p-103,
-	 0x1.3660p-102,
-	 0x1.d9d0p-103,
-	-0x1.02d0p-102,
-	 0x1.b070p-103,
-	 0x1.b9c0p-104,
-	-0x1.01c0p-103,
-	-0x1.dfe0p-103,
-	 0x1.1b60p-104,
-	-0x1.ae94p-101,
-	-0x1.3340p-104,
-	 0x1.b3d8p-102,
-	-0x1.6e40p-105,
-	-0x1.3670p-103,
-	 0x1.c140p-104,
-	 0x1.1840p-101,
-	 0x1.1ab0p-102,
-	-0x1.a400p-104,
-	 0x1.1f00p-104,
-	-0x1.7180p-103,
-	 0x1.4ce0p-102,
-	 0x1.9200p-107,
-	-0x1.54c0p-103,
-	 0x1.1b80p-105,
-	-0x1.1828p-101,
-	 0x1.5720p-102,
-	-0x1.a060p-100,
-	 0x1.9160p-102,
-	 0x1.a280p-104,
-	 0x1.3400p-107,
-	 0x1.2b20p-102,
-	 0x1.7800p-108,
-	 0x1.cfd0p-101,
-	 0x1.2ef0p-102,
-	-0x1.2760p-99,
-	 0x1.b380p-104,
-	 0x1.0048p-101,
-	-0x1.60b0p-102,
-	 0x1.a1ccp-100,
-	-0x1.a640p-104,
-	-0x1.08a0p-101,
-	 0x1.7e60p-102,
-	 0x1.22c0p-103,
-	-0x1.7200p-106,
-	 0x1.f0f0p-102,
-	 0x1.eb4ep-99,
-	 0x1.c6e0p-103,
-};
-
-/*
- * exp2l(x): compute the base 2 exponential of x
- *
- * Accuracy: Peak error < 0.502 ulp.
- *
- * Method: (accurate tables)
- *
- *   Reduce x:
- *     x = 2**k + y, for integer k and |y| <= 1/2.
- *     Thus we have exp2(x) = 2**k * exp2(y).
- *
- *   Reduce y:
- *     y = i/TBLSIZE + z - eps[i] for integer i near y * TBLSIZE.
- *     Thus we have exp2(y) = exp2(i/TBLSIZE) * exp2(z - eps[i]),
- *     with |z - eps[i]| <= 2**-8 + 2**-98 for the table used.
- *
- *   We compute exp2(i/TBLSIZE) via table lookup and exp2(z - eps[i]) via
- *   a degree-10 minimax polynomial with maximum error under 2**-120.
- *   The values in exp2t[] and eps[] are chosen such that
- *   exp2t[i] = exp2(i/TBLSIZE + eps[i]), and eps[i] is a small offset such
- *   that exp2t[i] is accurate to 2**-122.
- *
- *   Note that the range of i is +-TBLSIZE/2, so we actually index the tables
- *   by i0 = i + TBLSIZE/2.
- *
- *   This method is due to Gal, with many details due to Gal and Bachelis:
- *
- *	Gal, S. and Bachelis, B.  An Accurate Elementary Mathematical Library
- *	for the IEEE Floating Point Standard.  TOMS 17(1), 26-46 (1991).
- */
-long double
-exp2l(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	long double r, z, t;
-	uint32_t i0;
-	union {uint32_t u; int32_t i;} k;
-
-	/* Filter out exceptional cases. */
-	if (e >= 0x3fff + 14) {  /* |x| >= 16384 or x is NaN */
-		if (u.i.se >= 0x3fff + 15 && u.i.se >> 15 == 0)
-			/* overflow */
-			return x * 0x1p16383L;
-		if (e == 0x7fff)  /* -inf or -nan */
-			return -1/x;
-		if (x < -16382) {
-			if (x <= -16495 || x - 0x1p112 + 0x1p112 != x)
-				/* underflow */
-				FORCE_EVAL((float)(-0x1p-149/x));
-			if (x <= -16446)
-				return 0;
-		}
-	} else if (e < 0x3fff - 114) {
-		return 1 + x;
-	}
-
-	/*
-	 * Reduce x, computing z, i0, and k. The low bits of x + redux
-	 * contain the 16-bit integer part of the exponent (k) followed by
-	 * TBLBITS fractional bits (i0). We use bit tricks to extract these
-	 * as integers, then set z to the remainder.
-	 *
-	 * Example: Suppose x is 0xabc.123456p0 and TBLBITS is 8.
-	 * Then the low-order word of x + redux is 0x000abc12,
-	 * We split this into k = 0xabc and i0 = 0x12 (adjusted to
-	 * index into the table), then we compute z = 0x0.003456p0.
-	 */
-	u.f = x + redux;
-	i0 = u.i2.lo + TBLSIZE / 2;
-	k.u = i0 / TBLSIZE * TBLSIZE;
-	k.i /= TBLSIZE;
-	i0 %= TBLSIZE;
-	u.f -= redux;
-	z = x - u.f;
-
-	/* Compute r = exp2(y) = exp2t[i0] * p(z - eps[i]). */
-	t = tbl[i0];
-	z -= eps[i0];
-	r = t + t * z * (P1 + z * (P2 + z * (P3 + z * (P4 + z * (P5 + z * (P6
-	    + z * (P7 + z * (P8 + z * (P9 + z * P10)))))))));
-
-	return scalbnl(r, k.i);
-}
-#endif
diff --git a/libc/src/musl/math/expf.c b/libc/src/musl/math/expf.c
deleted file mode 100644
index 16e9afe..0000000
--- a/libc/src/musl/math/expf.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_expf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float
-half[2] = {0.5,-0.5},
-ln2hi   = 6.9314575195e-1f,  /* 0x3f317200 */
-ln2lo   = 1.4286067653e-6f,  /* 0x35bfbe8e */
-invln2  = 1.4426950216e+0f,  /* 0x3fb8aa3b */
-/*
- * Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]:
- * |x*(exp(x)+1)/(exp(x)-1) - p(x)| < 2**-27.74
- */
-P1 =  1.6666625440e-1f, /*  0xaaaa8f.0p-26 */
-P2 = -2.7667332906e-3f; /* -0xb55215.0p-32 */
-
-float expf(float x)
-{
-	float_t hi, lo, c, xx, y;
-	int k, sign;
-	uint32_t hx;
-
-	GET_FLOAT_WORD(hx, x);
-	sign = hx >> 31;   /* sign bit of x */
-	hx &= 0x7fffffff;  /* high word of |x| */
-
-	/* special cases */
-	if (hx >= 0x42aeac50) {  /* if |x| >= -87.33655f or NaN */
-		if (hx >= 0x42b17218 && !sign) {  /* x >= 88.722839f */
-			/* overflow */
-			x *= 0x1p127f;
-			return x;
-		}
-		if (sign) {
-			/* underflow */
-			FORCE_EVAL(-0x1p-149f/x);
-			if (hx >= 0x42cff1b5)  /* x <= -103.972084f */
-				return 0;
-		}
-	}
-
-	/* argument reduction */
-	if (hx > 0x3eb17218) {  /* if |x| > 0.5 ln2 */
-		if (hx > 0x3f851592)  /* if |x| > 1.5 ln2 */
-			k = invln2*x + half[sign];
-		else
-			k = 1 - sign - sign;
-		hi = x - k*ln2hi;  /* k*ln2hi is exact here */
-		lo = k*ln2lo;
-		x = hi - lo;
-	} else if (hx > 0x39000000) {  /* |x| > 2**-14 */
-		k = 0;
-		hi = x;
-		lo = 0;
-	} else {
-		/* raise inexact */
-		FORCE_EVAL(0x1p127f + x);
-		return 1 + x;
-	}
-
-	/* x is now in primary range */
-	xx = x*x;
-	c = x - xx*(P1+xx*P2);
-	y = 1 + (x*c/(2-c) - lo + hi);
-	if (k == 0)
-		return y;
-	return scalbnf(y, k);
-}
diff --git a/libc/src/musl/math/expl.c b/libc/src/musl/math/expl.c
deleted file mode 100644
index 0a7f44f..0000000
--- a/libc/src/musl/math/expl.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/e_expl.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Exponential function, long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, expl();
- *
- * y = expl( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns e (2.71828...) raised to the x power.
- *
- * Range reduction is accomplished by separating the argument
- * into an integer k and fraction f such that
- *
- *     x    k  f
- *    e  = 2  e.
- *
- * A Pade' form of degree 5/6 is used to approximate exp(f) - 1
- * in the basic range [-0.5 ln 2, 0.5 ln 2].
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE      +-10000     50000       1.12e-19    2.81e-20
- *
- *
- * Error amplification in the exponential function can be
- * a serious matter.  The error propagation involves
- * exp( X(1+delta) ) = exp(X) ( 1 + X*delta + ... ),
- * which shows that a 1 lsb error in representing X produces
- * a relative error of X times 1 lsb in the function.
- * While the routine gives an accurate result for arguments
- * that are exactly represented by a long double precision
- * computer number, the result contains amplified roundoff
- * error for large arguments not exactly represented.
- *
- *
- * ERROR MESSAGES:
- *
- *   message         condition      value returned
- * exp underflow    x < MINLOG         0.0
- * exp overflow     x > MAXLOG         MAXNUM
- *
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double expl(long double x)
-{
-	return exp(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-
-static const long double P[3] = {
- 1.2617719307481059087798E-4L,
- 3.0299440770744196129956E-2L,
- 9.9999999999999999991025E-1L,
-};
-static const long double Q[4] = {
- 3.0019850513866445504159E-6L,
- 2.5244834034968410419224E-3L,
- 2.2726554820815502876593E-1L,
- 2.0000000000000000000897E0L,
-};
-static const long double
-LN2HI = 6.9314575195312500000000E-1L,
-LN2LO = 1.4286068203094172321215E-6L,
-LOG2E = 1.4426950408889634073599E0L;
-
-long double expl(long double x)
-{
-	long double px, xx;
-	int k;
-
-	if (isnan(x))
-		return x;
-	if (x > 11356.5234062941439488L) /* x > ln(2^16384 - 0.5) */
-		return x * 0x1p16383L;
-	if (x < -11399.4985314888605581L) /* x < ln(2^-16446) */
-		return -0x1p-16445L/x;
-
-	/* Express e**x = e**f 2**k
-	 *   = e**(f + k ln(2))
-	 */
-	px = floorl(LOG2E * x + 0.5);
-	k = px;
-	x -= px * LN2HI;
-	x -= px * LN2LO;
-
-	/* rational approximation of the fractional part:
-	 * e**x =  1 + 2x P(x**2)/(Q(x**2) - x P(x**2))
-	 */
-	xx = x * x;
-	px = x * __polevll(xx, P, 2);
-	x = px/(__polevll(xx, Q, 3) - px);
-	x = 1.0 + 2.0 * x;
-	return scalbnl(x, k);
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double expl(long double x)
-{
-	return exp(x);
-}
-#endif
diff --git a/libc/src/musl/math/expm1.c b/libc/src/musl/math/expm1.c
deleted file mode 100644
index ac1e61e..0000000
--- a/libc/src/musl/math/expm1.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_expm1.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* expm1(x)
- * Returns exp(x)-1, the exponential of x minus 1.
- *
- * Method
- *   1. Argument reduction:
- *      Given x, find r and integer k such that
- *
- *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658
- *
- *      Here a correction term c will be computed to compensate
- *      the error in r when rounded to a floating-point number.
- *
- *   2. Approximating expm1(r) by a special rational function on
- *      the interval [0,0.34658]:
- *      Since
- *          r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 - r^4/360 + ...
- *      we define R1(r*r) by
- *          r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 * R1(r*r)
- *      That is,
- *          R1(r**2) = 6/r *((exp(r)+1)/(exp(r)-1) - 2/r)
- *                   = 6/r * ( 1 + 2.0*(1/(exp(r)-1) - 1/r))
- *                   = 1 - r^2/60 + r^4/2520 - r^6/100800 + ...
- *      We use a special Remez algorithm on [0,0.347] to generate
- *      a polynomial of degree 5 in r*r to approximate R1. The
- *      maximum error of this polynomial approximation is bounded
- *      by 2**-61. In other words,
- *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5
- *      where   Q1  =  -1.6666666666666567384E-2,
- *              Q2  =   3.9682539681370365873E-4,
- *              Q3  =  -9.9206344733435987357E-6,
- *              Q4  =   2.5051361420808517002E-7,
- *              Q5  =  -6.2843505682382617102E-9;
- *              z   =  r*r,
- *      with error bounded by
- *          |                  5           |     -61
- *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2
- *          |                              |
- *
- *      expm1(r) = exp(r)-1 is then computed by the following
- *      specific way which minimize the accumulation rounding error:
- *                             2     3
- *                            r     r    [ 3 - (R1 + R1*r/2)  ]
- *            expm1(r) = r + --- + --- * [--------------------]
- *                            2     2    [ 6 - r*(3 - R1*r/2) ]
- *
- *      To compensate the error in the argument reduction, we use
- *              expm1(r+c) = expm1(r) + c + expm1(r)*c
- *                         ~ expm1(r) + c + r*c
- *      Thus c+r*c will be added in as the correction terms for
- *      expm1(r+c). Now rearrange the term to avoid optimization
- *      screw up:
- *                      (      2                                    2 )
- *                      ({  ( r    [ R1 -  (3 - R1*r/2) ]  )  }    r  )
- *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )
- *                      ({  ( 2    [ 6 - r*(3 - R1*r/2) ]  )  }    2  )
- *                      (                                             )
- *
- *                 = r - E
- *   3. Scale back to obtain expm1(x):
- *      From step 1, we have
- *         expm1(x) = either 2^k*[expm1(r)+1] - 1
- *                  = or     2^k*[expm1(r) + (1-2^-k)]
- *   4. Implementation notes:
- *      (A). To save one multiplication, we scale the coefficient Qi
- *           to Qi*2^i, and replace z by (x^2)/2.
- *      (B). To achieve maximum accuracy, we compute expm1(x) by
- *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)
- *        (ii)  if k=0, return r-E
- *        (iii) if k=-1, return 0.5*(r-E)-0.5
- *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)
- *                     else          return  1.0+2.0*(r-E);
- *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)
- *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else
- *        (vii) return 2^k(1-((E+2^-k)-r))
- *
- * Special cases:
- *      expm1(INF) is INF, expm1(NaN) is NaN;
- *      expm1(-INF) is -1, and
- *      for finite argument, only expm1(0)=0 is exact.
- *
- * Accuracy:
- *      according to an error analysis, the error is always less than
- *      1 ulp (unit in the last place).
- *
- * Misc. info.
- *      For IEEE double
- *          if x >  7.09782712893383973096e+02 then expm1(x) overflow
- *
- * Constants:
- * The hexadecimal values are the intended ones for the following
- * constants. The decimal values may be used, provided that the
- * compiler will convert from decimal to binary accurately enough
- * to produce the hexadecimal values shown.
- */
-
-#include "libm.h"
-
-static const double
-o_threshold = 7.09782712893383973096e+02, /* 0x40862E42, 0xFEFA39EF */
-ln2_hi      = 6.93147180369123816490e-01, /* 0x3fe62e42, 0xfee00000 */
-ln2_lo      = 1.90821492927058770002e-10, /* 0x3dea39ef, 0x35793c76 */
-invln2      = 1.44269504088896338700e+00, /* 0x3ff71547, 0x652b82fe */
-/* Scaled Q's: Qn_here = 2**n * Qn_above, for R(2*z) where z = hxs = x*x/2: */
-Q1 = -3.33333333333331316428e-02, /* BFA11111 111110F4 */
-Q2 =  1.58730158725481460165e-03, /* 3F5A01A0 19FE5585 */
-Q3 = -7.93650757867487942473e-05, /* BF14CE19 9EAADBB7 */
-Q4 =  4.00821782732936239552e-06, /* 3ED0CFCA 86E65239 */
-Q5 = -2.01099218183624371326e-07; /* BE8AFDB7 6E09C32D */
-
-double expm1(double x)
-{
-	double_t y,hi,lo,c,t,e,hxs,hfx,r1,twopk;
-	union {double f; uint64_t i;} u = {x};
-	uint32_t hx = u.i>>32 & 0x7fffffff;
-	int k, sign = u.i>>63;
-
-	/* filter out huge and non-finite argument */
-	if (hx >= 0x4043687A) {  /* if |x|>=56*ln2 */
-		if (isnan(x))
-			return x;
-		if (sign)
-			return -1;
-		if (x > o_threshold) {
-			x *= 0x1p1023;
-			return x;
-		}
-	}
-
-	/* argument reduction */
-	if (hx > 0x3fd62e42) {  /* if  |x| > 0.5 ln2 */
-		if (hx < 0x3FF0A2B2) {  /* and |x| < 1.5 ln2 */
-			if (!sign) {
-				hi = x - ln2_hi;
-				lo = ln2_lo;
-				k =  1;
-			} else {
-				hi = x + ln2_hi;
-				lo = -ln2_lo;
-				k = -1;
-			}
-		} else {
-			k  = invln2*x + (sign ? -0.5 : 0.5);
-			t  = k;
-			hi = x - t*ln2_hi;  /* t*ln2_hi is exact here */
-			lo = t*ln2_lo;
-		}
-		x = hi-lo;
-		c = (hi-x)-lo;
-	} else if (hx < 0x3c900000) {  /* |x| < 2**-54, return x */
-		if (hx < 0x00100000)
-			FORCE_EVAL((float)x);
-		return x;
-	} else
-		k = 0;
-
-	/* x is now in primary range */
-	hfx = 0.5*x;
-	hxs = x*hfx;
-	r1 = 1.0+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));
-	t  = 3.0-r1*hfx;
-	e  = hxs*((r1-t)/(6.0 - x*t));
-	if (k == 0)   /* c is 0 */
-		return x - (x*e-hxs);
-	e  = x*(e-c) - c;
-	e -= hxs;
-	/* exp(x) ~ 2^k (x_reduced - e + 1) */
-	if (k == -1)
-		return 0.5*(x-e) - 0.5;
-	if (k == 1) {
-		if (x < -0.25)
-			return -2.0*(e-(x+0.5));
-		return 1.0+2.0*(x-e);
-	}
-	u.i = (uint64_t)(0x3ff + k)<<52;  /* 2^k */
-	twopk = u.f;
-	if (k < 0 || k > 56) {  /* suffice to return exp(x)-1 */
-		y = x - e + 1.0;
-		if (k == 1024)
-			y = y*2.0*0x1p1023;
-		else
-			y = y*twopk;
-		return y - 1.0;
-	}
-	u.i = (uint64_t)(0x3ff - k)<<52;  /* 2^-k */
-	if (k < 20)
-		y = (x-e+(1-u.f))*twopk;
-	else
-		y = (x-(e+u.f)+1)*twopk;
-	return y;
-}
diff --git a/libc/src/musl/math/expm1f.c b/libc/src/musl/math/expm1f.c
deleted file mode 100644
index 297e0b4..0000000
--- a/libc/src/musl/math/expm1f.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_expm1f.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float
-o_threshold = 8.8721679688e+01, /* 0x42b17180 */
-ln2_hi      = 6.9313812256e-01, /* 0x3f317180 */
-ln2_lo      = 9.0580006145e-06, /* 0x3717f7d1 */
-invln2      = 1.4426950216e+00, /* 0x3fb8aa3b */
-/*
- * Domain [-0.34568, 0.34568], range ~[-6.694e-10, 6.696e-10]:
- * |6 / x * (1 + 2 * (1 / (exp(x) - 1) - 1 / x)) - q(x)| < 2**-30.04
- * Scaled coefficients: Qn_here = 2**n * Qn_for_q (see s_expm1.c):
- */
-Q1 = -3.3333212137e-2, /* -0x888868.0p-28 */
-Q2 =  1.5807170421e-3; /*  0xcf3010.0p-33 */
-
-float expm1f(float x)
-{
-	float_t y,hi,lo,c,t,e,hxs,hfx,r1,twopk;
-	union {float f; uint32_t i;} u = {x};
-	uint32_t hx = u.i & 0x7fffffff;
-	int k, sign = u.i >> 31;
-
-	/* filter out huge and non-finite argument */
-	if (hx >= 0x4195b844) {  /* if |x|>=27*ln2 */
-		if (hx > 0x7f800000)  /* NaN */
-			return x;
-		if (sign)
-			return -1;
-		if (x > o_threshold) {
-			x *= 0x1p127f;
-			return x;
-		}
-	}
-
-	/* argument reduction */
-	if (hx > 0x3eb17218) {           /* if  |x| > 0.5 ln2 */
-		if (hx < 0x3F851592) {       /* and |x| < 1.5 ln2 */
-			if (!sign) {
-				hi = x - ln2_hi;
-				lo = ln2_lo;
-				k =  1;
-			} else {
-				hi = x + ln2_hi;
-				lo = -ln2_lo;
-				k = -1;
-			}
-		} else {
-			k  = invln2*x + (sign ? -0.5f : 0.5f);
-			t  = k;
-			hi = x - t*ln2_hi;      /* t*ln2_hi is exact here */
-			lo = t*ln2_lo;
-		}
-		x = hi-lo;
-		c = (hi-x)-lo;
-	} else if (hx < 0x33000000) {  /* when |x|<2**-25, return x */
-		if (hx < 0x00800000)
-			FORCE_EVAL(x*x);
-		return x;
-	} else
-		k = 0;
-
-	/* x is now in primary range */
-	hfx = 0.5f*x;
-	hxs = x*hfx;
-	r1 = 1.0f+hxs*(Q1+hxs*Q2);
-	t  = 3.0f - r1*hfx;
-	e  = hxs*((r1-t)/(6.0f - x*t));
-	if (k == 0)  /* c is 0 */
-		return x - (x*e-hxs);
-	e  = x*(e-c) - c;
-	e -= hxs;
-	/* exp(x) ~ 2^k (x_reduced - e + 1) */
-	if (k == -1)
-		return 0.5f*(x-e) - 0.5f;
-	if (k == 1) {
-		if (x < -0.25f)
-			return -2.0f*(e-(x+0.5f));
-		return 1.0f + 2.0f*(x-e);
-	}
-	u.i = (0x7f+k)<<23;  /* 2^k */
-	twopk = u.f;
-	if (k < 0 || k > 56) {   /* suffice to return exp(x)-1 */
-		y = x - e + 1.0f;
-		if (k == 128)
-			y = y*2.0f*0x1p127f;
-		else
-			y = y*twopk;
-		return y - 1.0f;
-	}
-	u.i = (0x7f-k)<<23;  /* 2^-k */
-	if (k < 23)
-		y = (x-e+(1-u.f))*twopk;
-	else
-		y = (x-(e+u.f)+1)*twopk;
-	return y;
-}
diff --git a/libc/src/musl/math/expm1l.c b/libc/src/musl/math/expm1l.c
deleted file mode 100644
index d171507..0000000
--- a/libc/src/musl/math/expm1l.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/e_expm1l.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Exponential function, minus 1
- *      Long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, expm1l();
- *
- * y = expm1l( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns e (2.71828...) raised to the x power, minus 1.
- *
- * Range reduction is accomplished by separating the argument
- * into an integer k and fraction f such that
- *
- *     x    k  f
- *    e  = 2  e.
- *
- * An expansion x + .5 x^2 + x^3 R(x) approximates exp(f) - 1
- * in the basic range [-0.5 ln 2, 0.5 ln 2].
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE    -45,+maxarg   200,000     1.2e-19     2.5e-20
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double expm1l(long double x)
-{
-	return expm1(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-
-/* exp(x) - 1 = x + 0.5 x^2 + x^3 P(x)/Q(x)
-   -.5 ln 2  <  x  <  .5 ln 2
-   Theoretical peak relative error = 3.4e-22  */
-static const long double
-P0 = -1.586135578666346600772998894928250240826E4L,
-P1 =  2.642771505685952966904660652518429479531E3L,
-P2 = -3.423199068835684263987132888286791620673E2L,
-P3 =  1.800826371455042224581246202420972737840E1L,
-P4 = -5.238523121205561042771939008061958820811E-1L,
-Q0 = -9.516813471998079611319047060563358064497E4L,
-Q1 =  3.964866271411091674556850458227710004570E4L,
-Q2 = -7.207678383830091850230366618190187434796E3L,
-Q3 =  7.206038318724600171970199625081491823079E2L,
-Q4 = -4.002027679107076077238836622982900945173E1L,
-/* Q5 = 1.000000000000000000000000000000000000000E0 */
-/* C1 + C2 = ln 2 */
-C1 = 6.93145751953125E-1L,
-C2 = 1.428606820309417232121458176568075500134E-6L,
-/* ln 2^-65 */
-minarg = -4.5054566736396445112120088E1L,
-/* ln 2^16384 */
-maxarg = 1.1356523406294143949492E4L;
-
-long double expm1l(long double x)
-{
-	long double px, qx, xx;
-	int k;
-
-	if (isnan(x))
-		return x;
-	if (x > maxarg)
-		return x*0x1p16383L; /* overflow, unless x==inf */
-	if (x == 0.0)
-		return x;
-	if (x < minarg)
-		return -1.0;
-
-	xx = C1 + C2;
-	/* Express x = ln 2 (k + remainder), remainder not exceeding 1/2. */
-	px = floorl(0.5 + x / xx);
-	k = px;
-	/* remainder times ln 2 */
-	x -= px * C1;
-	x -= px * C2;
-
-	/* Approximate exp(remainder ln 2).*/
-	px = (((( P4 * x + P3) * x + P2) * x + P1) * x + P0) * x;
-	qx = (((( x + Q4) * x + Q3) * x + Q2) * x + Q1) * x + Q0;
-	xx = x * x;
-	qx = x + (0.5 * xx + xx * px / qx);
-
-	/* exp(x) = exp(k ln 2) exp(remainder ln 2) = 2^k exp(remainder ln 2).
-	 We have qx = exp(remainder ln 2) - 1, so
-	 exp(x) - 1  =  2^k (qx + 1) - 1  =  2^k qx + 2^k - 1.  */
-	px = scalbnl(1.0, k);
-	x = px * qx + (px - 1.0);
-	return x;
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double expm1l(long double x)
-{
-	return expm1(x);
-}
-#endif
diff --git a/libc/src/musl/math/fabs.c b/libc/src/musl/math/fabs.c
deleted file mode 100644
index e8258cf..0000000
--- a/libc/src/musl/math/fabs.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-double fabs(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	u.i &= -1ULL/2;
-	return u.f;
-}
diff --git a/libc/src/musl/math/fabsf.c b/libc/src/musl/math/fabsf.c
deleted file mode 100644
index 4efc8d6..0000000
--- a/libc/src/musl/math/fabsf.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-float fabsf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	u.i &= 0x7fffffff;
-	return u.f;
-}
diff --git a/libc/src/musl/math/fabsl.c b/libc/src/musl/math/fabsl.c
deleted file mode 100644
index c4f36ec..0000000
--- a/libc/src/musl/math/fabsl.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include "libm.h"
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double fabsl(long double x)
-{
-	return fabs(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-long double fabsl(long double x)
-{
-	union ldshape u = {x};
-
-	u.i.se &= 0x7fff;
-	return u.f;
-}
-#endif
diff --git a/libc/src/musl/math/floor.c b/libc/src/musl/math/floor.c
deleted file mode 100644
index 14a31cd..0000000
--- a/libc/src/musl/math/floor.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include "libm.h"
-
-#if FLT_EVAL_METHOD==0 || FLT_EVAL_METHOD==1
-#define EPS DBL_EPSILON
-#elif FLT_EVAL_METHOD==2
-#define EPS LDBL_EPSILON
-#endif
-static const double_t toint = 1/EPS;
-
-double floor(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	int e = u.i >> 52 & 0x7ff;
-	double_t y;
-
-	if (e >= 0x3ff+52 || x == 0)
-		return x;
-	/* y = int(x) - x, where int(x) is an integer neighbor of x */
-	if (u.i >> 63)
-		y = x - toint + toint - x;
-	else
-		y = x + toint - toint - x;
-	/* special case because of non-nearest rounding modes */
-	if (e <= 0x3ff-1) {
-		FORCE_EVAL(y);
-		return u.i >> 63 ? -1 : 0;
-	}
-	if (y > 0)
-		return x + y - 1;
-	return x + y;
-}
diff --git a/libc/src/musl/math/floorf.c b/libc/src/musl/math/floorf.c
deleted file mode 100644
index dceec73..0000000
--- a/libc/src/musl/math/floorf.c
+++ /dev/null
@@ -1,27 +0,0 @@
-#include "libm.h"
-
-float floorf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
-	uint32_t m;
-
-	if (e >= 23)
-		return x;
-	if (e >= 0) {
-		m = 0x007fffff >> e;
-		if ((u.i & m) == 0)
-			return x;
-		FORCE_EVAL(x + 0x1p120f);
-		if (u.i >> 31)
-			u.i += m;
-		u.i &= ~m;
-	} else {
-		FORCE_EVAL(x + 0x1p120f);
-		if (u.i >> 31 == 0)
-			u.i = 0;
-		else if (u.i << 1)
-			u.f = -1.0;
-	}
-	return u.f;
-}
diff --git a/libc/src/musl/math/floorl.c b/libc/src/musl/math/floorl.c
deleted file mode 100644
index 16aaec4..0000000
--- a/libc/src/musl/math/floorl.c
+++ /dev/null
@@ -1,34 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double floorl(long double x)
-{
-	return floor(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-
-static const long double toint = 1/LDBL_EPSILON;
-
-long double floorl(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	long double y;
-
-	if (e >= 0x3fff+LDBL_MANT_DIG-1 || x == 0)
-		return x;
-	/* y = int(x) - x, where int(x) is an integer neighbor of x */
-	if (u.i.se >> 15)
-		y = x - toint + toint - x;
-	else
-		y = x + toint - toint - x;
-	/* special case because of non-nearest rounding modes */
-	if (e <= 0x3fff-1) {
-		FORCE_EVAL(y);
-		return u.i.se >> 15 ? -1 : 0;
-	}
-	if (y > 0)
-		return x + y - 1;
-	return x + y;
-}
-#endif
diff --git a/libc/src/musl/math/fmod.c b/libc/src/musl/math/fmod.c
deleted file mode 100644
index 6849722..0000000
--- a/libc/src/musl/math/fmod.c
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-double fmod(double x, double y)
-{
-	union {double f; uint64_t i;} ux = {x}, uy = {y};
-	int ex = ux.i>>52 & 0x7ff;
-	int ey = uy.i>>52 & 0x7ff;
-	int sx = ux.i>>63;
-	uint64_t i;
-
-	/* in the followings uxi should be ux.i, but then gcc wrongly adds */
-	/* float load/store to inner loops ruining performance and code size */
-	uint64_t uxi = ux.i;
-
-	if (uy.i<<1 == 0 || isnan(y) || ex == 0x7ff)
-		return (x*y)/(x*y);
-	if (uxi<<1 <= uy.i<<1) {
-		if (uxi<<1 == uy.i<<1)
-			return 0*x;
-		return x;
-	}
-
-	/* normalize x and y */
-	if (!ex) {
-		for (i = uxi<<12; i>>63 == 0; ex--, i <<= 1);
-		uxi <<= -ex + 1;
-	} else {
-		uxi &= -1ULL >> 12;
-		uxi |= 1ULL << 52;
-	}
-	if (!ey) {
-		for (i = uy.i<<12; i>>63 == 0; ey--, i <<= 1);
-		uy.i <<= -ey + 1;
-	} else {
-		uy.i &= -1ULL >> 12;
-		uy.i |= 1ULL << 52;
-	}
-
-	/* x mod y */
-	for (; ex > ey; ex--) {
-		i = uxi - uy.i;
-		if (i >> 63 == 0) {
-			if (i == 0)
-				return 0*x;
-			uxi = i;
-		}
-		uxi <<= 1;
-	}
-	i = uxi - uy.i;
-	if (i >> 63 == 0) {
-		if (i == 0)
-			return 0*x;
-		uxi = i;
-	}
-	for (; uxi>>52 == 0; uxi <<= 1, ex--);
-
-	/* scale result */
-	if (ex > 0) {
-		uxi -= 1ULL << 52;
-		uxi |= (uint64_t)ex << 52;
-	} else {
-		uxi >>= -ex + 1;
-	}
-	uxi |= (uint64_t)sx << 63;
-	ux.i = uxi;
-	return ux.f;
-}
diff --git a/libc/src/musl/math/fmodf.c b/libc/src/musl/math/fmodf.c
deleted file mode 100644
index ff58f93..0000000
--- a/libc/src/musl/math/fmodf.c
+++ /dev/null
@@ -1,65 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-float fmodf(float x, float y)
-{
-	union {float f; uint32_t i;} ux = {x}, uy = {y};
-	int ex = ux.i>>23 & 0xff;
-	int ey = uy.i>>23 & 0xff;
-	uint32_t sx = ux.i & 0x80000000;
-	uint32_t i;
-	uint32_t uxi = ux.i;
-
-	if (uy.i<<1 == 0 || isnan(y) || ex == 0xff)
-		return (x*y)/(x*y);
-	if (uxi<<1 <= uy.i<<1) {
-		if (uxi<<1 == uy.i<<1)
-			return 0*x;
-		return x;
-	}
-
-	/* normalize x and y */
-	if (!ex) {
-		for (i = uxi<<9; i>>31 == 0; ex--, i <<= 1);
-		uxi <<= -ex + 1;
-	} else {
-		uxi &= -1U >> 9;
-		uxi |= 1U << 23;
-	}
-	if (!ey) {
-		for (i = uy.i<<9; i>>31 == 0; ey--, i <<= 1);
-		uy.i <<= -ey + 1;
-	} else {
-		uy.i &= -1U >> 9;
-		uy.i |= 1U << 23;
-	}
-
-	/* x mod y */
-	for (; ex > ey; ex--) {
-		i = uxi - uy.i;
-		if (i >> 31 == 0) {
-			if (i == 0)
-				return 0*x;
-			uxi = i;
-		}
-		uxi <<= 1;
-	}
-	i = uxi - uy.i;
-	if (i >> 31 == 0) {
-		if (i == 0)
-			return 0*x;
-		uxi = i;
-	}
-	for (; uxi>>23 == 0; uxi <<= 1, ex--);
-
-	/* scale result up */
-	if (ex > 0) {
-		uxi -= 1U << 23;
-		uxi |= (uint32_t)ex << 23;
-	} else {
-		uxi >>= -ex + 1;
-	}
-	uxi |= sx;
-	ux.i = uxi;
-	return ux.f;
-}
diff --git a/libc/src/musl/math/fmodl.c b/libc/src/musl/math/fmodl.c
deleted file mode 100644
index 9f5b873..0000000
--- a/libc/src/musl/math/fmodl.c
+++ /dev/null
@@ -1,105 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double fmodl(long double x, long double y)
-{
-	return fmod(x, y);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-long double fmodl(long double x, long double y)
-{
-	union ldshape ux = {x}, uy = {y};
-	int ex = ux.i.se & 0x7fff;
-	int ey = uy.i.se & 0x7fff;
-	int sx = ux.i.se & 0x8000;
-
-	if (y == 0 || isnan(y) || ex == 0x7fff)
-		return (x*y)/(x*y);
-	ux.i.se = ex;
-	uy.i.se = ey;
-	if (ux.f <= uy.f) {
-		if (ux.f == uy.f)
-			return 0*x;
-		return x;
-	}
-
-	/* normalize x and y */
-	if (!ex) {
-		ux.f *= 0x1p120f;
-		ex = ux.i.se - 120;
-	}
-	if (!ey) {
-		uy.f *= 0x1p120f;
-		ey = uy.i.se - 120;
-	}
-
-	/* x mod y */
-#if LDBL_MANT_DIG == 64
-	uint64_t i, mx, my;
-	mx = ux.i.m;
-	my = uy.i.m;
-	for (; ex > ey; ex--) {
-		i = mx - my;
-		if (mx >= my) {
-			if (i == 0)
-				return 0*x;
-			mx = 2*i;
-		} else if (2*mx < mx) {
-			mx = 2*mx - my;
-		} else {
-			mx = 2*mx;
-		}
-	}
-	i = mx - my;
-	if (mx >= my) {
-		if (i == 0)
-			return 0*x;
-		mx = i;
-	}
-	for (; mx >> 63 == 0; mx *= 2, ex--);
-	ux.i.m = mx;
-#elif LDBL_MANT_DIG == 113
-	uint64_t hi, lo, xhi, xlo, yhi, ylo;
-	xhi = (ux.i2.hi & -1ULL>>16) | 1ULL<<48;
-	yhi = (uy.i2.hi & -1ULL>>16) | 1ULL<<48;
-	xlo = ux.i2.lo;
-	ylo = uy.i2.lo;
-	for (; ex > ey; ex--) {
-		hi = xhi - yhi;
-		lo = xlo - ylo;
-		if (xlo < ylo)
-			hi -= 1;
-		if (hi >> 63 == 0) {
-			if ((hi|lo) == 0)
-				return 0*x;
-			xhi = 2*hi + (lo>>63);
-			xlo = 2*lo;
-		} else {
-			xhi = 2*xhi + (xlo>>63);
-			xlo = 2*xlo;
-		}
-	}
-	hi = xhi - yhi;
-	lo = xlo - ylo;
-	if (xlo < ylo)
-		hi -= 1;
-	if (hi >> 63 == 0) {
-		if ((hi|lo) == 0)
-			return 0*x;
-		xhi = hi;
-		xlo = lo;
-	}
-	for (; xhi >> 48 == 0; xhi = 2*xhi + (xlo>>63), xlo = 2*xlo, ex--);
-	ux.i2.hi = xhi;
-	ux.i2.lo = xlo;
-#endif
-
-	/* scale result */
-	if (ex <= 0) {
-		ux.i.se = (ex+120)|sx;
-		ux.f *= 0x1p-120f;
-	} else
-		ux.i.se = ex|sx;
-	return ux.f;
-}
-#endif
diff --git a/libc/src/musl/math/hypot.c b/libc/src/musl/math/hypot.c
deleted file mode 100644
index 29ec6a4..0000000
--- a/libc/src/musl/math/hypot.c
+++ /dev/null
@@ -1,67 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-#include <float.h>
-
-#if FLT_EVAL_METHOD > 1U && LDBL_MANT_DIG == 64
-#define SPLIT (0x1p32 + 1)
-#else
-#define SPLIT (0x1p27 + 1)
-#endif
-
-static void sq(double_t *hi, double_t *lo, double x)
-{
-	double_t xh, xl, xc;
-
-	xc = x*SPLIT;
-	xh = x - xc + xc;
-	xl = x - xh;
-	*hi = x*x;
-	*lo = xh*xh - *hi + 2*xh*xl + xl*xl;
-}
-
-double hypot(double x, double y)
-{
-	union {double f; uint64_t i;} ux = {x}, uy = {y}, ut;
-	int ex, ey;
-	double_t hx, lx, hy, ly, z;
-
-	/* arrange |x| >= |y| */
-	ux.i &= -1ULL>>1;
-	uy.i &= -1ULL>>1;
-	if (ux.i < uy.i) {
-		ut = ux;
-		ux = uy;
-		uy = ut;
-	}
-
-	/* special cases */
-	ex = ux.i>>52;
-	ey = uy.i>>52;
-	x = ux.f;
-	y = uy.f;
-	/* note: hypot(inf,nan) == inf */
-	if (ey == 0x7ff)
-		return y;
-	if (ex == 0x7ff || uy.i == 0)
-		return x;
-	/* note: hypot(x,y) ~= x + y*y/x/2 with inexact for small y/x */
-	/* 64 difference is enough for ld80 double_t */
-	if (ex - ey > 64)
-		return x + y;
-
-	/* precise sqrt argument in nearest rounding mode without overflow */
-	/* xh*xh must not overflow and xl*xl must not underflow in sq */
-	z = 1;
-	if (ex > 0x3ff+510) {
-		z = 0x1p700;
-		x *= 0x1p-700;
-		y *= 0x1p-700;
-	} else if (ey < 0x3ff-450) {
-		z = 0x1p-700;
-		x *= 0x1p700;
-		y *= 0x1p700;
-	}
-	sq(&hx, &lx, x);
-	sq(&hy, &ly, y);
-	return z*sqrt(ly+lx+hy+hx);
-}
diff --git a/libc/src/musl/math/hypotf.c b/libc/src/musl/math/hypotf.c
deleted file mode 100644
index 2fc214b..0000000
--- a/libc/src/musl/math/hypotf.c
+++ /dev/null
@@ -1,35 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-float hypotf(float x, float y)
-{
-	union {float f; uint32_t i;} ux = {x}, uy = {y}, ut;
-	float_t z;
-
-	ux.i &= -1U>>1;
-	uy.i &= -1U>>1;
-	if (ux.i < uy.i) {
-		ut = ux;
-		ux = uy;
-		uy = ut;
-	}
-
-	x = ux.f;
-	y = uy.f;
-	if (uy.i == 0xff<<23)
-		return y;
-	if (ux.i >= 0xff<<23 || uy.i == 0 || ux.i - uy.i >= 25<<23)
-		return x + y;
-
-	z = 1;
-	if (ux.i >= (0x7f+60)<<23) {
-		z = 0x1p90f;
-		x *= 0x1p-90f;
-		y *= 0x1p-90f;
-	} else if (uy.i < (0x7f-60)<<23) {
-		z = 0x1p-90f;
-		x *= 0x1p90f;
-		y *= 0x1p90f;
-	}
-	return z*sqrtf((double)x*x + (double)y*y);
-}
diff --git a/libc/src/musl/math/ldexp.c b/libc/src/musl/math/ldexp.c
deleted file mode 100644
index f4d1cd6..0000000
--- a/libc/src/musl/math/ldexp.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <math.h>
-
-double ldexp(double x, int n)
-{
-	return scalbn(x, n);
-}
diff --git a/libc/src/musl/math/ldexpf.c b/libc/src/musl/math/ldexpf.c
deleted file mode 100644
index 3bad5f3..0000000
--- a/libc/src/musl/math/ldexpf.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <math.h>
-
-float ldexpf(float x, int n)
-{
-	return scalbnf(x, n);
-}
diff --git a/libc/src/musl/math/ldexpl.c b/libc/src/musl/math/ldexpl.c
deleted file mode 100644
index fd145cc..0000000
--- a/libc/src/musl/math/ldexpl.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <math.h>
-
-long double ldexpl(long double x, int n)
-{
-	return scalbnl(x, n);
-}
diff --git a/libc/src/musl/math/llrint.c b/libc/src/musl/math/llrint.c
deleted file mode 100644
index 4f583ae..0000000
--- a/libc/src/musl/math/llrint.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-/* uses LLONG_MAX > 2^53, see comments in lrint.c */
-
-long long llrint(double x)
-{
-	return rint(x);
-}
diff --git a/libc/src/musl/math/llrintf.c b/libc/src/musl/math/llrintf.c
deleted file mode 100644
index 96949a0..0000000
--- a/libc/src/musl/math/llrintf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-/* uses LLONG_MAX > 2^24, see comments in lrint.c */
-
-long long llrintf(float x)
-{
-	return rintf(x);
-}
diff --git a/libc/src/musl/math/llrintl.c b/libc/src/musl/math/llrintl.c
deleted file mode 100644
index 3449f6f..0000000
--- a/libc/src/musl/math/llrintl.c
+++ /dev/null
@@ -1,36 +0,0 @@
-#include <limits.h>
-#include <fenv.h>
-#include "libm.h"
-
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long long llrintl(long double x)
-{
-	return llrint(x);
-}
-#elif defined(FE_INEXACT)
-/*
-see comments in lrint.c
-
-Note that if LLONG_MAX == 0x7fffffffffffffff && LDBL_MANT_DIG == 64
-then x == 2**63 - 0.5 is the only input that overflows and
-raises inexact (with tonearest or upward rounding mode)
-*/
-long long llrintl(long double x)
-{
-	#pragma STDC FENV_ACCESS ON
-	int e;
-
-	e = fetestexcept(FE_INEXACT);
-	x = rintl(x);
-	if (!e && (x > LLONG_MAX || x < LLONG_MIN))
-		feclearexcept(FE_INEXACT);
-	/* conversion */
-	return x;
-}
-#else
-long long llrintl(long double x)
-{
-	return rintl(x);
-}
-#endif
diff --git a/libc/src/musl/math/log.c b/libc/src/musl/math/log.c
deleted file mode 100644
index e61e113..0000000
--- a/libc/src/musl/math/log.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_log.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* log(x)
- * Return the logarithm of x
- *
- * Method :
- *   1. Argument Reduction: find k and f such that
- *                      x = 2^k * (1+f),
- *         where  sqrt(2)/2 < 1+f < sqrt(2) .
- *
- *   2. Approximation of log(1+f).
- *      Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
- *               = 2s + 2/3 s**3 + 2/5 s**5 + .....,
- *               = 2s + s*R
- *      We use a special Remez algorithm on [0,0.1716] to generate
- *      a polynomial of degree 14 to approximate R The maximum error
- *      of this polynomial approximation is bounded by 2**-58.45. In
- *      other words,
- *                      2      4      6      8      10      12      14
- *          R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
- *      (the values of Lg1 to Lg7 are listed in the program)
- *      and
- *          |      2          14          |     -58.45
- *          | Lg1*s +...+Lg7*s    -  R(z) | <= 2
- *          |                             |
- *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
- *      In order to guarantee error in log below 1ulp, we compute log
- *      by
- *              log(1+f) = f - s*(f - R)        (if f is not too large)
- *              log(1+f) = f - (hfsq - s*(hfsq+R)).     (better accuracy)
- *
- *      3. Finally,  log(x) = k*ln2 + log(1+f).
- *                          = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
- *         Here ln2 is split into two floating point number:
- *                      ln2_hi + ln2_lo,
- *         where n*ln2_hi is always exact for |n| < 2000.
- *
- * Special cases:
- *      log(x) is NaN with signal if x < 0 (including -INF) ;
- *      log(+INF) is +INF; log(0) is -INF with signal;
- *      log(NaN) is that NaN with no signal.
- *
- * Accuracy:
- *      according to an error analysis, the error is always less than
- *      1 ulp (unit in the last place).
- *
- * Constants:
- * The hexadecimal values are the intended ones for the following
- * constants. The decimal values may be used, provided that the
- * compiler will convert from decimal to binary accurately enough
- * to produce the hexadecimal values shown.
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const double
-ln2_hi = 6.93147180369123816490e-01,  /* 3fe62e42 fee00000 */
-ln2_lo = 1.90821492927058770002e-10,  /* 3dea39ef 35793c76 */
-Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
-Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
-Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
-Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
-Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
-Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
-Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
-
-double log(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	double_t hfsq,f,s,z,R,w,t1,t2,dk;
-	uint32_t hx;
-	int k;
-
-	hx = u.i>>32;
-	k = 0;
-	if (hx < 0x00100000 || hx>>31) {
-		if (u.i<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (hx>>31)
-			return (x-x)/0.0; /* log(-#) = NaN */
-		/* subnormal number, scale x up */
-		k -= 54;
-		x *= 0x1p54;
-		u.f = x;
-		hx = u.i>>32;
-	} else if (hx >= 0x7ff00000) {
-		return x;
-	} else if (hx == 0x3ff00000 && u.i<<32 == 0)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	hx += 0x3ff00000 - 0x3fe6a09e;
-	k += (int)(hx>>20) - 0x3ff;
-	hx = (hx&0x000fffff) + 0x3fe6a09e;
-	u.i = (uint64_t)hx<<32 | (u.i&0xffffffff);
-	x = u.f;
-
-	f = x - 1.0;
-	hfsq = 0.5*f*f;
-	s = f/(2.0+f);
-	z = s*s;
-	w = z*z;
-	t1 = w*(Lg2+w*(Lg4+w*Lg6));
-	t2 = z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
-	R = t2 + t1;
-	dk = k;
-	return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;
-}
diff --git a/libc/src/musl/math/log10.c b/libc/src/musl/math/log10.c
deleted file mode 100644
index 8102687..0000000
--- a/libc/src/musl/math/log10.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_log10.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * Return the base 10 logarithm of x.  See log.c for most comments.
- *
- * Reduce x to 2^k (1+f) and calculate r = log(1+f) - f + f*f/2
- * as in log.c, then combine and scale in extra precision:
- *    log10(x) = (f - f*f/2 + r)/log(10) + k*log10(2)
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const double
-ivln10hi  = 4.34294481878168880939e-01, /* 0x3fdbcb7b, 0x15200000 */
-ivln10lo  = 2.50829467116452752298e-11, /* 0x3dbb9438, 0xca9aadd5 */
-log10_2hi = 3.01029995663611771306e-01, /* 0x3FD34413, 0x509F6000 */
-log10_2lo = 3.69423907715893078616e-13, /* 0x3D59FEF3, 0x11F12B36 */
-Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
-Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
-Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
-Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
-Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
-Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
-Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
-
-double log10(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	double_t hfsq,f,s,z,R,w,t1,t2,dk,y,hi,lo,val_hi,val_lo;
-	uint32_t hx;
-	int k;
-
-	hx = u.i>>32;
-	k = 0;
-	if (hx < 0x00100000 || hx>>31) {
-		if (u.i<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (hx>>31)
-			return (x-x)/0.0; /* log(-#) = NaN */
-		/* subnormal number, scale x up */
-		k -= 54;
-		x *= 0x1p54;
-		u.f = x;
-		hx = u.i>>32;
-	} else if (hx >= 0x7ff00000) {
-		return x;
-	} else if (hx == 0x3ff00000 && u.i<<32 == 0)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	hx += 0x3ff00000 - 0x3fe6a09e;
-	k += (int)(hx>>20) - 0x3ff;
-	hx = (hx&0x000fffff) + 0x3fe6a09e;
-	u.i = (uint64_t)hx<<32 | (u.i&0xffffffff);
-	x = u.f;
-
-	f = x - 1.0;
-	hfsq = 0.5*f*f;
-	s = f/(2.0+f);
-	z = s*s;
-	w = z*z;
-	t1 = w*(Lg2+w*(Lg4+w*Lg6));
-	t2 = z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
-	R = t2 + t1;
-
-	/* See log2.c for details. */
-	/* hi+lo = f - hfsq + s*(hfsq+R) ~ log(1+f) */
-	hi = f - hfsq;
-	u.f = hi;
-	u.i &= (uint64_t)-1<<32;
-	hi = u.f;
-	lo = f - hi - hfsq + s*(hfsq+R);
-
-	/* val_hi+val_lo ~ log10(1+f) + k*log10(2) */
-	val_hi = hi*ivln10hi;
-	dk = k;
-	y = dk*log10_2hi;
-	val_lo = dk*log10_2lo + (lo+hi)*ivln10lo + lo*ivln10hi;
-
-	/*
-	 * Extra precision in for adding y is not strictly needed
-	 * since there is no very large cancellation near x = sqrt(2) or
-	 * x = 1/sqrt(2), but we do it anyway since it costs little on CPUs
-	 * with some parallelism and it reduces the error for many args.
-	 */
-	w = y + val_hi;
-	val_lo += (y - w) + val_hi;
-	val_hi = w;
-
-	return val_lo + val_hi;
-}
diff --git a/libc/src/musl/math/log10f.c b/libc/src/musl/math/log10f.c
deleted file mode 100644
index 9ca2f01..0000000
--- a/libc/src/musl/math/log10f.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_log10f.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * See comments in log10.c.
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const float
-ivln10hi  =  4.3432617188e-01, /* 0x3ede6000 */
-ivln10lo  = -3.1689971365e-05, /* 0xb804ead9 */
-log10_2hi =  3.0102920532e-01, /* 0x3e9a2080 */
-log10_2lo =  7.9034151668e-07, /* 0x355427db */
-/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
-Lg1 = 0xaaaaaa.0p-24, /* 0.66666662693 */
-Lg2 = 0xccce13.0p-25, /* 0.40000972152 */
-Lg3 = 0x91e9ee.0p-25, /* 0.28498786688 */
-Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
-
-float log10f(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	float_t hfsq,f,s,z,R,w,t1,t2,dk,hi,lo;
-	uint32_t ix;
-	int k;
-
-	ix = u.i;
-	k = 0;
-	if (ix < 0x00800000 || ix>>31) {  /* x < 2**-126  */
-		if (ix<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (ix>>31)
-			return (x-x)/0.0f; /* log(-#) = NaN */
-		/* subnormal number, scale up x */
-		k -= 25;
-		x *= 0x1p25f;
-		u.f = x;
-		ix = u.i;
-	} else if (ix >= 0x7f800000) {
-		return x;
-	} else if (ix == 0x3f800000)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	ix += 0x3f800000 - 0x3f3504f3;
-	k += (int)(ix>>23) - 0x7f;
-	ix = (ix&0x007fffff) + 0x3f3504f3;
-	u.i = ix;
-	x = u.f;
-
-	f = x - 1.0f;
-	s = f/(2.0f + f);
-	z = s*s;
-	w = z*z;
-	t1= w*(Lg2+w*Lg4);
-	t2= z*(Lg1+w*Lg3);
-	R = t2 + t1;
-	hfsq = 0.5f*f*f;
-
-	hi = f - hfsq;
-	u.f = hi;
-	u.i &= 0xfffff000;
-	hi = u.f;
-	lo = f - hi - hfsq + s*(hfsq+R);
-	dk = k;
-	return dk*log10_2lo + (lo+hi)*ivln10lo + lo*ivln10hi + hi*ivln10hi + dk*log10_2hi;
-}
diff --git a/libc/src/musl/math/log10l.c b/libc/src/musl/math/log10l.c
deleted file mode 100644
index 63dcc28..0000000
--- a/libc/src/musl/math/log10l.c
+++ /dev/null
@@ -1,191 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/e_log10l.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Common logarithm, long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, log10l();
- *
- * y = log10l( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns the base 10 logarithm of x.
- *
- * The argument is separated into its exponent and fractional
- * parts.  If the exponent is between -1 and +1, the logarithm
- * of the fraction is approximated by
- *
- *     log(1+x) = x - 0.5 x**2 + x**3 P(x)/Q(x).
- *
- * Otherwise, setting  z = 2(x-1)/x+1),
- *
- *     log(x) = z + z**3 P(z)/Q(z).
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE      0.5, 2.0     30000      9.0e-20     2.6e-20
- *    IEEE     exp(+-10000)  30000      6.0e-20     2.3e-20
- *
- * In the tests over the interval exp(+-10000), the logarithms
- * of the random arguments were uniformly distributed over
- * [-10000, +10000].
- *
- * ERROR MESSAGES:
- *
- * log singularity:  x = 0; returns MINLOG
- * log domain:       x < 0; returns MINLOG
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double log10l(long double x)
-{
-	return log10(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-/* Coefficients for log(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.2e-22
- */
-static const long double P[] = {
- 4.9962495940332550844739E-1L,
- 1.0767376367209449010438E1L,
- 7.7671073698359539859595E1L,
- 2.5620629828144409632571E2L,
- 4.2401812743503691187826E2L,
- 3.4258224542413922935104E2L,
- 1.0747524399916215149070E2L,
-};
-static const long double Q[] = {
-/* 1.0000000000000000000000E0,*/
- 2.3479774160285863271658E1L,
- 1.9444210022760132894510E2L,
- 7.7952888181207260646090E2L,
- 1.6911722418503949084863E3L,
- 2.0307734695595183428202E3L,
- 1.2695660352705325274404E3L,
- 3.2242573199748645407652E2L,
-};
-
-/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
- * where z = 2(x-1)/(x+1)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.16e-22
- */
-static const long double R[4] = {
- 1.9757429581415468984296E-3L,
--7.1990767473014147232598E-1L,
- 1.0777257190312272158094E1L,
--3.5717684488096787370998E1L,
-};
-static const long double S[4] = {
-/* 1.00000000000000000000E0L,*/
--2.6201045551331104417768E1L,
- 1.9361891836232102174846E2L,
--4.2861221385716144629696E2L,
-};
-/* log10(2) */
-#define L102A 0.3125L
-#define L102B -1.1470004336018804786261e-2L
-/* log10(e) */
-#define L10EA 0.5L
-#define L10EB -6.5705518096748172348871e-2L
-
-#define SQRTH 0.70710678118654752440L
-
-long double log10l(long double x)
-{
-	long double y, z;
-	int e;
-
-	if (isnan(x))
-		return x;
-	if(x <= 0.0) {
-		if(x == 0.0)
-			return -1.0 / (x*x);
-		return (x - x) / 0.0;
-	}
-	if (x == INFINITY)
-		return INFINITY;
-	/* separate mantissa from exponent */
-	/* Note, frexp is used so that denormal numbers
-	 * will be handled properly.
-	 */
-	x = frexpl(x, &e);
-
-	/* logarithm using log(x) = z + z**3 P(z)/Q(z),
-	 * where z = 2(x-1)/x+1)
-	 */
-	if (e > 2 || e < -2) {
-		if (x < SQRTH) {  /* 2(2x-1)/(2x+1) */
-			e -= 1;
-			z = x - 0.5;
-			y = 0.5 * z + 0.5;
-		} else {  /*  2 (x-1)/(x+1)   */
-			z = x - 0.5;
-			z -= 0.5;
-			y = 0.5 * x  + 0.5;
-		}
-		x = z / y;
-		z = x*x;
-		y = x * (z * __polevll(z, R, 3) / __p1evll(z, S, 3));
-		goto done;
-	}
-
-	/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */
-	if (x < SQRTH) {
-		e -= 1;
-		x = 2.0*x - 1.0;
-	} else {
-		x = x - 1.0;
-	}
-	z = x*x;
-	y = x * (z * __polevll(x, P, 6) / __p1evll(x, Q, 7));
-	y = y - 0.5*z;
-
-done:
-	/* Multiply log of fraction by log10(e)
-	 * and base 2 exponent by log10(2).
-	 *
-	 * ***CAUTION***
-	 *
-	 * This sequence of operations is critical and it may
-	 * be horribly defeated by some compiler optimizers.
-	 */
-	z = y * (L10EB);
-	z += x * (L10EB);
-	z += e * (L102B);
-	z += y * (L10EA);
-	z += x * (L10EA);
-	z += e * (L102A);
-	return z;
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double log10l(long double x)
-{
-	return log10(x);
-}
-#endif
diff --git a/libc/src/musl/math/log1p.c b/libc/src/musl/math/log1p.c
deleted file mode 100644
index 0097134..0000000
--- a/libc/src/musl/math/log1p.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_log1p.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* double log1p(double x)
- * Return the natural logarithm of 1+x.
- *
- * Method :
- *   1. Argument Reduction: find k and f such that
- *                      1+x = 2^k * (1+f),
- *         where  sqrt(2)/2 < 1+f < sqrt(2) .
- *
- *      Note. If k=0, then f=x is exact. However, if k!=0, then f
- *      may not be representable exactly. In that case, a correction
- *      term is need. Let u=1+x rounded. Let c = (1+x)-u, then
- *      log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),
- *      and add back the correction term c/u.
- *      (Note: when x > 2**53, one can simply return log(x))
- *
- *   2. Approximation of log(1+f): See log.c
- *
- *   3. Finally, log1p(x) = k*ln2 + log(1+f) + c/u. See log.c
- *
- * Special cases:
- *      log1p(x) is NaN with signal if x < -1 (including -INF) ;
- *      log1p(+INF) is +INF; log1p(-1) is -INF with signal;
- *      log1p(NaN) is that NaN with no signal.
- *
- * Accuracy:
- *      according to an error analysis, the error is always less than
- *      1 ulp (unit in the last place).
- *
- * Constants:
- * The hexadecimal values are the intended ones for the following
- * constants. The decimal values may be used, provided that the
- * compiler will convert from decimal to binary accurately enough
- * to produce the hexadecimal values shown.
- *
- * Note: Assuming log() return accurate answer, the following
- *       algorithm can be used to compute log1p(x) to within a few ULP:
- *
- *              u = 1+x;
- *              if(u==1.0) return x ; else
- *                         return log(u)*(x/(u-1.0));
- *
- *       See HP-15C Advanced Functions Handbook, p.193.
- */
-
-#include "libm.h"
-
-static const double
-ln2_hi = 6.93147180369123816490e-01,  /* 3fe62e42 fee00000 */
-ln2_lo = 1.90821492927058770002e-10,  /* 3dea39ef 35793c76 */
-Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
-Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
-Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
-Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
-Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
-Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
-Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
-
-double log1p(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	double_t hfsq,f,c,s,z,R,w,t1,t2,dk;
-	uint32_t hx,hu;
-	int k;
-
-	hx = u.i>>32;
-	k = 1;
-	if (hx < 0x3fda827a || hx>>31) {  /* 1+x < sqrt(2)+ */
-		if (hx >= 0xbff00000) {  /* x <= -1.0 */
-			if (x == -1)
-				return x/0.0; /* log1p(-1) = -inf */
-			return (x-x)/0.0;     /* log1p(x<-1) = NaN */
-		}
-		if (hx<<1 < 0x3ca00000<<1) {  /* |x| < 2**-53 */
-			/* underflow if subnormal */
-			if ((hx&0x7ff00000) == 0)
-				FORCE_EVAL((float)x);
-			return x;
-		}
-		if (hx <= 0xbfd2bec4) {  /* sqrt(2)/2- <= 1+x < sqrt(2)+ */
-			k = 0;
-			c = 0;
-			f = x;
-		}
-	} else if (hx >= 0x7ff00000)
-		return x;
-	if (k) {
-		u.f = 1 + x;
-		hu = u.i>>32;
-		hu += 0x3ff00000 - 0x3fe6a09e;
-		k = (int)(hu>>20) - 0x3ff;
-		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
-		if (k < 54) {
-			c = k >= 2 ? 1-(u.f-x) : x-(u.f-1);
-			c /= u.f;
-		} else
-			c = 0;
-		/* reduce u into [sqrt(2)/2, sqrt(2)] */
-		hu = (hu&0x000fffff) + 0x3fe6a09e;
-		u.i = (uint64_t)hu<<32 | (u.i&0xffffffff);
-		f = u.f - 1;
-	}
-	hfsq = 0.5*f*f;
-	s = f/(2.0+f);
-	z = s*s;
-	w = z*z;
-	t1 = w*(Lg2+w*(Lg4+w*Lg6));
-	t2 = z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
-	R = t2 + t1;
-	dk = k;
-	return s*(hfsq+R) + (dk*ln2_lo+c) - hfsq + f + dk*ln2_hi;
-}
diff --git a/libc/src/musl/math/log1pf.c b/libc/src/musl/math/log1pf.c
deleted file mode 100644
index 23985c3..0000000
--- a/libc/src/musl/math/log1pf.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/s_log1pf.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float
-ln2_hi = 6.9313812256e-01, /* 0x3f317180 */
-ln2_lo = 9.0580006145e-06, /* 0x3717f7d1 */
-/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
-Lg1 = 0xaaaaaa.0p-24, /* 0.66666662693 */
-Lg2 = 0xccce13.0p-25, /* 0.40000972152 */
-Lg3 = 0x91e9ee.0p-25, /* 0.28498786688 */
-Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
-
-float log1pf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	float_t hfsq,f,c,s,z,R,w,t1,t2,dk;
-	uint32_t ix,iu;
-	int k;
-
-	ix = u.i;
-	k = 1;
-	if (ix < 0x3ed413d0 || ix>>31) {  /* 1+x < sqrt(2)+  */
-		if (ix >= 0xbf800000) {  /* x <= -1.0 */
-			if (x == -1)
-				return x/0.0f; /* log1p(-1)=+inf */
-			return (x-x)/0.0f;     /* log1p(x<-1)=NaN */
-		}
-		if (ix<<1 < 0x33800000<<1) {   /* |x| < 2**-24 */
-			/* underflow if subnormal */
-			if ((ix&0x7f800000) == 0)
-				FORCE_EVAL(x*x);
-			return x;
-		}
-		if (ix <= 0xbe95f619) { /* sqrt(2)/2- <= 1+x < sqrt(2)+ */
-			k = 0;
-			c = 0;
-			f = x;
-		}
-	} else if (ix >= 0x7f800000)
-		return x;
-	if (k) {
-		u.f = 1 + x;
-		iu = u.i;
-		iu += 0x3f800000 - 0x3f3504f3;
-		k = (int)(iu>>23) - 0x7f;
-		/* correction term ~ log(1+x)-log(u), avoid underflow in c/u */
-		if (k < 25) {
-			c = k >= 2 ? 1-(u.f-x) : x-(u.f-1);
-			c /= u.f;
-		} else
-			c = 0;
-		/* reduce u into [sqrt(2)/2, sqrt(2)] */
-		iu = (iu&0x007fffff) + 0x3f3504f3;
-		u.i = iu;
-		f = u.f - 1;
-	}
-	s = f/(2.0f + f);
-	z = s*s;
-	w = z*z;
-	t1= w*(Lg2+w*Lg4);
-	t2= z*(Lg1+w*Lg3);
-	R = t2 + t1;
-	hfsq = 0.5f*f*f;
-	dk = k;
-	return s*(hfsq+R) + (dk*ln2_lo+c) - hfsq + f + dk*ln2_hi;
-}
diff --git a/libc/src/musl/math/log1pl.c b/libc/src/musl/math/log1pl.c
deleted file mode 100644
index 141b5f0..0000000
--- a/libc/src/musl/math/log1pl.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/s_log1pl.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Relative error logarithm
- *      Natural logarithm of 1+x, long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, log1pl();
- *
- * y = log1pl( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns the base e (2.718...) logarithm of 1+x.
- *
- * The argument 1+x is separated into its exponent and fractional
- * parts.  If the exponent is between -1 and +1, the logarithm
- * of the fraction is approximated by
- *
- *     log(1+x) = x - 0.5 x^2 + x^3 P(x)/Q(x).
- *
- * Otherwise, setting  z = 2(x-1)/x+1),
- *
- *     log(x) = z + z^3 P(z)/Q(z).
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE     -1.0, 9.0    100000      8.2e-20    2.5e-20
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double log1pl(long double x)
-{
-	return log1p(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-/* Coefficients for log(1+x) = x - x^2 / 2 + x^3 P(x)/Q(x)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 2.32e-20
- */
-static const long double P[] = {
- 4.5270000862445199635215E-5L,
- 4.9854102823193375972212E-1L,
- 6.5787325942061044846969E0L,
- 2.9911919328553073277375E1L,
- 6.0949667980987787057556E1L,
- 5.7112963590585538103336E1L,
- 2.0039553499201281259648E1L,
-};
-static const long double Q[] = {
-/* 1.0000000000000000000000E0,*/
- 1.5062909083469192043167E1L,
- 8.3047565967967209469434E1L,
- 2.2176239823732856465394E2L,
- 3.0909872225312059774938E2L,
- 2.1642788614495947685003E2L,
- 6.0118660497603843919306E1L,
-};
-
-/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
- * where z = 2(x-1)/(x+1)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.16e-22
- */
-static const long double R[4] = {
- 1.9757429581415468984296E-3L,
--7.1990767473014147232598E-1L,
- 1.0777257190312272158094E1L,
--3.5717684488096787370998E1L,
-};
-static const long double S[4] = {
-/* 1.00000000000000000000E0L,*/
--2.6201045551331104417768E1L,
- 1.9361891836232102174846E2L,
--4.2861221385716144629696E2L,
-};
-static const long double C1 = 6.9314575195312500000000E-1L;
-static const long double C2 = 1.4286068203094172321215E-6L;
-
-#define SQRTH 0.70710678118654752440L
-
-long double log1pl(long double xm1)
-{
-	long double x, y, z;
-	int e;
-
-	if (isnan(xm1))
-		return xm1;
-	if (xm1 == INFINITY)
-		return xm1;
-	if (xm1 == 0.0)
-		return xm1;
-
-	x = xm1 + 1.0;
-
-	/* Test for domain errors.  */
-	if (x <= 0.0) {
-		if (x == 0.0)
-			return -1/(x*x); /* -inf with divbyzero */
-		return 0/0.0f; /* nan with invalid */
-	}
-
-	/* Separate mantissa from exponent.
-	   Use frexp so that denormal numbers will be handled properly.  */
-	x = frexpl(x, &e);
-
-	/* logarithm using log(x) = z + z^3 P(z)/Q(z),
-	   where z = 2(x-1)/x+1)  */
-	if (e > 2 || e < -2) {
-		if (x < SQRTH) { /* 2(2x-1)/(2x+1) */
-			e -= 1;
-			z = x - 0.5;
-			y = 0.5 * z + 0.5;
-		} else { /*  2 (x-1)/(x+1)   */
-			z = x - 0.5;
-			z -= 0.5;
-			y = 0.5 * x  + 0.5;
-		}
-		x = z / y;
-		z = x*x;
-		z = x * (z * __polevll(z, R, 3) / __p1evll(z, S, 3));
-		z = z + e * C2;
-		z = z + x;
-		z = z + e * C1;
-		return z;
-	}
-
-	/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */
-	if (x < SQRTH) {
-		e -= 1;
-		if (e != 0)
-			x = 2.0 * x - 1.0;
-		else
-			x = xm1;
-	} else {
-		if (e != 0)
-			x = x - 1.0;
-		else
-			x = xm1;
-	}
-	z = x*x;
-	y = x * (z * __polevll(x, P, 6) / __p1evll(x, Q, 6));
-	y = y + e * C2;
-	z = y - 0.5 * z;
-	z = z + x;
-	z = z + e * C1;
-	return z;
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double log1pl(long double x)
-{
-	return log1p(x);
-}
-#endif
diff --git a/libc/src/musl/math/log2.c b/libc/src/musl/math/log2.c
deleted file mode 100644
index 0aafad4..0000000
--- a/libc/src/musl/math/log2.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_log2.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * Return the base 2 logarithm of x.  See log.c for most comments.
- *
- * Reduce x to 2^k (1+f) and calculate r = log(1+f) - f + f*f/2
- * as in log.c, then combine and scale in extra precision:
- *    log2(x) = (f - f*f/2 + r)/log(2) + k
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const double
-ivln2hi = 1.44269504072144627571e+00, /* 0x3ff71547, 0x65200000 */
-ivln2lo = 1.67517131648865118353e-10, /* 0x3de705fc, 0x2eefa200 */
-Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
-Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
-Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
-Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
-Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
-Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
-Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */
-
-double log2(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	double_t hfsq,f,s,z,R,w,t1,t2,y,hi,lo,val_hi,val_lo;
-	uint32_t hx;
-	int k;
-
-	hx = u.i>>32;
-	k = 0;
-	if (hx < 0x00100000 || hx>>31) {
-		if (u.i<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (hx>>31)
-			return (x-x)/0.0; /* log(-#) = NaN */
-		/* subnormal number, scale x up */
-		k -= 54;
-		x *= 0x1p54;
-		u.f = x;
-		hx = u.i>>32;
-	} else if (hx >= 0x7ff00000) {
-		return x;
-	} else if (hx == 0x3ff00000 && u.i<<32 == 0)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	hx += 0x3ff00000 - 0x3fe6a09e;
-	k += (int)(hx>>20) - 0x3ff;
-	hx = (hx&0x000fffff) + 0x3fe6a09e;
-	u.i = (uint64_t)hx<<32 | (u.i&0xffffffff);
-	x = u.f;
-
-	f = x - 1.0;
-	hfsq = 0.5*f*f;
-	s = f/(2.0+f);
-	z = s*s;
-	w = z*z;
-	t1 = w*(Lg2+w*(Lg4+w*Lg6));
-	t2 = z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));
-	R = t2 + t1;
-
-	/*
-	 * f-hfsq must (for args near 1) be evaluated in extra precision
-	 * to avoid a large cancellation when x is near sqrt(2) or 1/sqrt(2).
-	 * This is fairly efficient since f-hfsq only depends on f, so can
-	 * be evaluated in parallel with R.  Not combining hfsq with R also
-	 * keeps R small (though not as small as a true `lo' term would be),
-	 * so that extra precision is not needed for terms involving R.
-	 *
-	 * Compiler bugs involving extra precision used to break Dekker's
-	 * theorem for spitting f-hfsq as hi+lo, unless double_t was used
-	 * or the multi-precision calculations were avoided when double_t
-	 * has extra precision.  These problems are now automatically
-	 * avoided as a side effect of the optimization of combining the
-	 * Dekker splitting step with the clear-low-bits step.
-	 *
-	 * y must (for args near sqrt(2) and 1/sqrt(2)) be added in extra
-	 * precision to avoid a very large cancellation when x is very near
-	 * these values.  Unlike the above cancellations, this problem is
-	 * specific to base 2.  It is strange that adding +-1 is so much
-	 * harder than adding +-ln2 or +-log10_2.
-	 *
-	 * This uses Dekker's theorem to normalize y+val_hi, so the
-	 * compiler bugs are back in some configurations, sigh.  And I
-	 * don't want to used double_t to avoid them, since that gives a
-	 * pessimization and the support for avoiding the pessimization
-	 * is not yet available.
-	 *
-	 * The multi-precision calculations for the multiplications are
-	 * routine.
-	 */
-
-	/* hi+lo = f - hfsq + s*(hfsq+R) ~ log(1+f) */
-	hi = f - hfsq;
-	u.f = hi;
-	u.i &= (uint64_t)-1<<32;
-	hi = u.f;
-	lo = f - hi - hfsq + s*(hfsq+R);
-
-	val_hi = hi*ivln2hi;
-	val_lo = (lo+hi)*ivln2lo + lo*ivln2hi;
-
-	/* spadd(val_hi, val_lo, y), except for not using double_t: */
-	y = k;
-	w = y + val_hi;
-	val_lo += (y - w) + val_hi;
-	val_hi = w;
-
-	return val_lo + val_hi;
-}
diff --git a/libc/src/musl/math/log2f.c b/libc/src/musl/math/log2f.c
deleted file mode 100644
index b3e305f..0000000
--- a/libc/src/musl/math/log2f.c
+++ /dev/null
@@ -1,74 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_log2f.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/*
- * See comments in log2.c.
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const float
-ivln2hi =  1.4428710938e+00, /* 0x3fb8b000 */
-ivln2lo = -1.7605285393e-04, /* 0xb9389ad4 */
-/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
-Lg1 = 0xaaaaaa.0p-24, /* 0.66666662693 */
-Lg2 = 0xccce13.0p-25, /* 0.40000972152 */
-Lg3 = 0x91e9ee.0p-25, /* 0.28498786688 */
-Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
-
-float log2f(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	float_t hfsq,f,s,z,R,w,t1,t2,hi,lo;
-	uint32_t ix;
-	int k;
-
-	ix = u.i;
-	k = 0;
-	if (ix < 0x00800000 || ix>>31) {  /* x < 2**-126  */
-		if (ix<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (ix>>31)
-			return (x-x)/0.0f; /* log(-#) = NaN */
-		/* subnormal number, scale up x */
-		k -= 25;
-		x *= 0x1p25f;
-		u.f = x;
-		ix = u.i;
-	} else if (ix >= 0x7f800000) {
-		return x;
-	} else if (ix == 0x3f800000)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	ix += 0x3f800000 - 0x3f3504f3;
-	k += (int)(ix>>23) - 0x7f;
-	ix = (ix&0x007fffff) + 0x3f3504f3;
-	u.i = ix;
-	x = u.f;
-
-	f = x - 1.0f;
-	s = f/(2.0f + f);
-	z = s*s;
-	w = z*z;
-	t1= w*(Lg2+w*Lg4);
-	t2= z*(Lg1+w*Lg3);
-	R = t2 + t1;
-	hfsq = 0.5f*f*f;
-
-	hi = f - hfsq;
-	u.f = hi;
-	u.i &= 0xfffff000;
-	hi = u.f;
-	lo = f - hi - hfsq + s*(hfsq+R);
-	return (lo+hi)*ivln2lo + lo*ivln2hi + hi*ivln2hi + k;
-}
diff --git a/libc/src/musl/math/log2l.c b/libc/src/musl/math/log2l.c
deleted file mode 100644
index 722b451..0000000
--- a/libc/src/musl/math/log2l.c
+++ /dev/null
@@ -1,182 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/e_log2l.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Base 2 logarithm, long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, log2l();
- *
- * y = log2l( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns the base 2 logarithm of x.
- *
- * The argument is separated into its exponent and fractional
- * parts.  If the exponent is between -1 and +1, the (natural)
- * logarithm of the fraction is approximated by
- *
- *     log(1+x) = x - 0.5 x**2 + x**3 P(x)/Q(x).
- *
- * Otherwise, setting  z = 2(x-1)/x+1),
- *
- *     log(x) = z + z**3 P(z)/Q(z).
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE      0.5, 2.0     30000      9.8e-20     2.7e-20
- *    IEEE     exp(+-10000)  70000      5.4e-20     2.3e-20
- *
- * In the tests over the interval exp(+-10000), the logarithms
- * of the random arguments were uniformly distributed over
- * [-10000, +10000].
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double log2l(long double x)
-{
-	return log2(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-/* Coefficients for ln(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.2e-22
- */
-static const long double P[] = {
- 4.9962495940332550844739E-1L,
- 1.0767376367209449010438E1L,
- 7.7671073698359539859595E1L,
- 2.5620629828144409632571E2L,
- 4.2401812743503691187826E2L,
- 3.4258224542413922935104E2L,
- 1.0747524399916215149070E2L,
-};
-static const long double Q[] = {
-/* 1.0000000000000000000000E0,*/
- 2.3479774160285863271658E1L,
- 1.9444210022760132894510E2L,
- 7.7952888181207260646090E2L,
- 1.6911722418503949084863E3L,
- 2.0307734695595183428202E3L,
- 1.2695660352705325274404E3L,
- 3.2242573199748645407652E2L,
-};
-
-/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
- * where z = 2(x-1)/(x+1)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.16e-22
- */
-static const long double R[4] = {
- 1.9757429581415468984296E-3L,
--7.1990767473014147232598E-1L,
- 1.0777257190312272158094E1L,
--3.5717684488096787370998E1L,
-};
-static const long double S[4] = {
-/* 1.00000000000000000000E0L,*/
--2.6201045551331104417768E1L,
- 1.9361891836232102174846E2L,
--4.2861221385716144629696E2L,
-};
-/* log2(e) - 1 */
-#define LOG2EA 4.4269504088896340735992e-1L
-
-#define SQRTH 0.70710678118654752440L
-
-long double log2l(long double x)
-{
-	long double y, z;
-	int e;
-
-	if (isnan(x))
-		return x;
-	if (x == INFINITY)
-		return x;
-	if (x <= 0.0) {
-		if (x == 0.0)
-			return -1/(x*x); /* -inf with divbyzero */
-		return 0/0.0f; /* nan with invalid */
-	}
-
-	/* separate mantissa from exponent */
-	/* Note, frexp is used so that denormal numbers
-	 * will be handled properly.
-	 */
-	x = frexpl(x, &e);
-
-	/* logarithm using log(x) = z + z**3 P(z)/Q(z),
-	 * where z = 2(x-1)/x+1)
-	 */
-	if (e > 2 || e < -2) {
-		if (x < SQRTH) {  /* 2(2x-1)/(2x+1) */
-			e -= 1;
-			z = x - 0.5;
-			y = 0.5 * z + 0.5;
-		} else {  /*  2 (x-1)/(x+1)   */
-			z = x - 0.5;
-			z -= 0.5;
-			y = 0.5 * x + 0.5;
-		}
-		x = z / y;
-		z = x*x;
-		y = x * (z * __polevll(z, R, 3) / __p1evll(z, S, 3));
-		goto done;
-	}
-
-	/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */
-	if (x < SQRTH) {
-		e -= 1;
-		x = 2.0*x - 1.0;
-	} else {
-		x = x - 1.0;
-	}
-	z = x*x;
-	y = x * (z * __polevll(x, P, 6) / __p1evll(x, Q, 7));
-	y = y - 0.5*z;
-
-done:
-	/* Multiply log of fraction by log2(e)
-	 * and base 2 exponent by 1
-	 *
-	 * ***CAUTION***
-	 *
-	 * This sequence of operations is critical and it may
-	 * be horribly defeated by some compiler optimizers.
-	 */
-	z = y * LOG2EA;
-	z += x * LOG2EA;
-	z += y;
-	z += x;
-	z += e;
-	return z;
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double log2l(long double x)
-{
-	return log2(x);
-}
-#endif
diff --git a/libc/src/musl/math/logf.c b/libc/src/musl/math/logf.c
deleted file mode 100644
index 52230a1..0000000
--- a/libc/src/musl/math/logf.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_logf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include <math.h>
-#include <stdint.h>
-
-static const float
-ln2_hi = 6.9313812256e-01, /* 0x3f317180 */
-ln2_lo = 9.0580006145e-06, /* 0x3717f7d1 */
-/* |(log(1+s)-log(1-s))/s - Lg(s)| < 2**-34.24 (~[-4.95e-11, 4.97e-11]). */
-Lg1 = 0xaaaaaa.0p-24, /* 0.66666662693 */
-Lg2 = 0xccce13.0p-25, /* 0.40000972152 */
-Lg3 = 0x91e9ee.0p-25, /* 0.28498786688 */
-Lg4 = 0xf89e26.0p-26; /* 0.24279078841 */
-
-float logf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	float_t hfsq,f,s,z,R,w,t1,t2,dk;
-	uint32_t ix;
-	int k;
-
-	ix = u.i;
-	k = 0;
-	if (ix < 0x00800000 || ix>>31) {  /* x < 2**-126  */
-		if (ix<<1 == 0)
-			return -1/(x*x);  /* log(+-0)=-inf */
-		if (ix>>31)
-			return (x-x)/0.0f; /* log(-#) = NaN */
-		/* subnormal number, scale up x */
-		k -= 25;
-		x *= 0x1p25f;
-		u.f = x;
-		ix = u.i;
-	} else if (ix >= 0x7f800000) {
-		return x;
-	} else if (ix == 0x3f800000)
-		return 0;
-
-	/* reduce x into [sqrt(2)/2, sqrt(2)] */
-	ix += 0x3f800000 - 0x3f3504f3;
-	k += (int)(ix>>23) - 0x7f;
-	ix = (ix&0x007fffff) + 0x3f3504f3;
-	u.i = ix;
-	x = u.f;
-
-	f = x - 1.0f;
-	s = f/(2.0f + f);
-	z = s*s;
-	w = z*z;
-	t1= w*(Lg2+w*Lg4);
-	t2= z*(Lg1+w*Lg3);
-	R = t2 + t1;
-	hfsq = 0.5f*f*f;
-	dk = k;
-	return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;
-}
diff --git a/libc/src/musl/math/logl.c b/libc/src/musl/math/logl.c
deleted file mode 100644
index 5d53659..0000000
--- a/libc/src/musl/math/logl.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/* origin: OpenBSD /usr/src/lib/libm/src/ld80/e_logl.c */
-/*
- * Copyright (c) 2008 Stephen L. Moshier <steve@moshier.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- *      Natural logarithm, long double precision
- *
- *
- * SYNOPSIS:
- *
- * long double x, y, logl();
- *
- * y = logl( x );
- *
- *
- * DESCRIPTION:
- *
- * Returns the base e (2.718...) logarithm of x.
- *
- * The argument is separated into its exponent and fractional
- * parts.  If the exponent is between -1 and +1, the logarithm
- * of the fraction is approximated by
- *
- *     log(1+x) = x - 0.5 x**2 + x**3 P(x)/Q(x).
- *
- * Otherwise, setting  z = 2(x-1)/(x+1),
- *
- *     log(x) = log(1+z/2) - log(1-z/2) = z + z**3 P(z)/Q(z).
- *
- *
- * ACCURACY:
- *
- *                      Relative error:
- * arithmetic   domain     # trials      peak         rms
- *    IEEE      0.5, 2.0    150000      8.71e-20    2.75e-20
- *    IEEE     exp(+-10000) 100000      5.39e-20    2.34e-20
- *
- * In the tests over the interval exp(+-10000), the logarithms
- * of the random arguments were uniformly distributed over
- * [-10000, +10000].
- */
-
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double logl(long double x)
-{
-	return log(x);
-}
-#elif LDBL_MANT_DIG == 64 && LDBL_MAX_EXP == 16384
-/* Coefficients for log(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 2.32e-20
- */
-static const long double P[] = {
- 4.5270000862445199635215E-5L,
- 4.9854102823193375972212E-1L,
- 6.5787325942061044846969E0L,
- 2.9911919328553073277375E1L,
- 6.0949667980987787057556E1L,
- 5.7112963590585538103336E1L,
- 2.0039553499201281259648E1L,
-};
-static const long double Q[] = {
-/* 1.0000000000000000000000E0,*/
- 1.5062909083469192043167E1L,
- 8.3047565967967209469434E1L,
- 2.2176239823732856465394E2L,
- 3.0909872225312059774938E2L,
- 2.1642788614495947685003E2L,
- 6.0118660497603843919306E1L,
-};
-
-/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
- * where z = 2(x-1)/(x+1)
- * 1/sqrt(2) <= x < sqrt(2)
- * Theoretical peak relative error = 6.16e-22
- */
-static const long double R[4] = {
- 1.9757429581415468984296E-3L,
--7.1990767473014147232598E-1L,
- 1.0777257190312272158094E1L,
--3.5717684488096787370998E1L,
-};
-static const long double S[4] = {
-/* 1.00000000000000000000E0L,*/
--2.6201045551331104417768E1L,
- 1.9361891836232102174846E2L,
--4.2861221385716144629696E2L,
-};
-static const long double C1 = 6.9314575195312500000000E-1L;
-static const long double C2 = 1.4286068203094172321215E-6L;
-
-#define SQRTH 0.70710678118654752440L
-
-long double logl(long double x)
-{
-	long double y, z;
-	int e;
-
-	if (isnan(x))
-		return x;
-	if (x == INFINITY)
-		return x;
-	if (x <= 0.0) {
-		if (x == 0.0)
-			return -1/(x*x); /* -inf with divbyzero */
-		return 0/0.0f; /* nan with invalid */
-	}
-
-	/* separate mantissa from exponent */
-	/* Note, frexp is used so that denormal numbers
-	 * will be handled properly.
-	 */
-	x = frexpl(x, &e);
-
-	/* logarithm using log(x) = z + z**3 P(z)/Q(z),
-	 * where z = 2(x-1)/(x+1)
-	 */
-	if (e > 2 || e < -2) {
-		if (x < SQRTH) {  /* 2(2x-1)/(2x+1) */
-			e -= 1;
-			z = x - 0.5;
-			y = 0.5 * z + 0.5;
-		} else {  /*  2 (x-1)/(x+1)   */
-			z = x - 0.5;
-			z -= 0.5;
-			y = 0.5 * x  + 0.5;
-		}
-		x = z / y;
-		z = x*x;
-		z = x * (z * __polevll(z, R, 3) / __p1evll(z, S, 3));
-		z = z + e * C2;
-		z = z + x;
-		z = z + e * C1;
-		return z;
-	}
-
-	/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */
-	if (x < SQRTH) {
-		e -= 1;
-		x = 2.0*x - 1.0;
-	} else {
-		x = x - 1.0;
-	}
-	z = x*x;
-	y = x * (z * __polevll(x, P, 6) / __p1evll(x, Q, 6));
-	y = y + e * C2;
-	z = y - 0.5*z;
-	/* Note, the sum of above terms does not exceed x/4,
-	 * so it contributes at most about 1/4 lsb to the error.
-	 */
-	z = z + x;
-	z = z + e * C1; /* This sum has an error of 1/2 lsb. */
-	return z;
-}
-#elif LDBL_MANT_DIG == 113 && LDBL_MAX_EXP == 16384
-// TODO: broken implementation to make things compile
-long double logl(long double x)
-{
-	return log(x);
-}
-#endif
diff --git a/libc/src/musl/math/lrint.c b/libc/src/musl/math/lrint.c
deleted file mode 100644
index bdca8b7..0000000
--- a/libc/src/musl/math/lrint.c
+++ /dev/null
@@ -1,46 +0,0 @@
-#include <limits.h>
-#include <fenv.h>
-#include "libm.h"
-
-/*
-If the result cannot be represented (overflow, nan), then
-lrint raises the invalid exception.
-
-Otherwise if the input was not an integer then the inexact
-exception is raised.
-
-C99 is a bit vague about whether inexact exception is
-allowed to be raised when invalid is raised.
-(F.9 explicitly allows spurious inexact exceptions, F.9.6.5
-does not make it clear if that rule applies to lrint, but
-IEEE 754r 7.8 seems to forbid spurious inexact exception in
-the ineger conversion functions)
-
-So we try to make sure that no spurious inexact exception is
-raised in case of an overflow.
-
-If the bit size of long > precision of double, then there
-cannot be inexact rounding in case the result overflows,
-otherwise LONG_MAX and LONG_MIN can be represented exactly
-as a double.
-*/
-
-#if LONG_MAX < 1U<<53 && defined(FE_INEXACT)
-long lrint(double x)
-{
-	#pragma STDC FENV_ACCESS ON
-	int e;
-
-	e = fetestexcept(FE_INEXACT);
-	x = rint(x);
-	if (!e && (x > LONG_MAX || x < LONG_MIN))
-		feclearexcept(FE_INEXACT);
-	/* conversion */
-	return x;
-}
-#else
-long lrint(double x)
-{
-	return rint(x);
-}
-#endif
diff --git a/libc/src/musl/math/lrintf.c b/libc/src/musl/math/lrintf.c
deleted file mode 100644
index ca0b6a4..0000000
--- a/libc/src/musl/math/lrintf.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <math.h>
-
-/* uses LONG_MAX > 2^24, see comments in lrint.c */
-
-long lrintf(float x)
-{
-	return rintf(x);
-}
diff --git a/libc/src/musl/math/lrintl.c b/libc/src/musl/math/lrintl.c
deleted file mode 100644
index b2a8106..0000000
--- a/libc/src/musl/math/lrintl.c
+++ /dev/null
@@ -1,36 +0,0 @@
-#include <limits.h>
-#include <fenv.h>
-#include "libm.h"
-
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long lrintl(long double x)
-{
-	return lrint(x);
-}
-#elif defined(FE_INEXACT)
-/*
-see comments in lrint.c
-
-Note that if LONG_MAX == 0x7fffffffffffffff && LDBL_MANT_DIG == 64
-then x == 2**63 - 0.5 is the only input that overflows and
-raises inexact (with tonearest or upward rounding mode)
-*/
-long lrintl(long double x)
-{
-	#pragma STDC FENV_ACCESS ON
-	int e;
-
-	e = fetestexcept(FE_INEXACT);
-	x = rintl(x);
-	if (!e && (x > LONG_MAX || x < LONG_MIN))
-		feclearexcept(FE_INEXACT);
-	/* conversion */
-	return x;
-}
-#else
-long lrintl(long double x)
-{
-	return rintl(x);
-}
-#endif
diff --git a/libc/src/musl/math/remainder.c b/libc/src/musl/math/remainder.c
deleted file mode 100644
index 6cd089c..0000000
--- a/libc/src/musl/math/remainder.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-#include "libc.h"
-
-double remainder(double x, double y)
-{
-	int q;
-	return remquo(x, y, &q);
-}
-
-weak_alias(remainder, drem);
diff --git a/libc/src/musl/math/remainderf.c b/libc/src/musl/math/remainderf.c
deleted file mode 100644
index 420d3bf..0000000
--- a/libc/src/musl/math/remainderf.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-#include "libc.h"
-
-float remainderf(float x, float y)
-{
-	int q;
-	return remquof(x, y, &q);
-}
-
-weak_alias(remainderf, dremf);
diff --git a/libc/src/musl/math/remainderl.c b/libc/src/musl/math/remainderl.c
deleted file mode 100644
index 2a13c1d..0000000
--- a/libc/src/musl/math/remainderl.c
+++ /dev/null
@@ -1,15 +0,0 @@
-#include <math.h>
-#include <float.h>
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double remainderl(long double x, long double y)
-{
-	return remainder(x, y);
-}
-#else
-long double remainderl(long double x, long double y)
-{
-	int q;
-	return remquol(x, y, &q);
-}
-#endif
diff --git a/libc/src/musl/math/remquo.c b/libc/src/musl/math/remquo.c
deleted file mode 100644
index 59d5ad5..0000000
--- a/libc/src/musl/math/remquo.c
+++ /dev/null
@@ -1,82 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-double remquo(double x, double y, int *quo)
-{
-	union {double f; uint64_t i;} ux = {x}, uy = {y};
-	int ex = ux.i>>52 & 0x7ff;
-	int ey = uy.i>>52 & 0x7ff;
-	int sx = ux.i>>63;
-	int sy = uy.i>>63;
-	uint32_t q;
-	uint64_t i;
-	uint64_t uxi = ux.i;
-
-	*quo = 0;
-	if (uy.i<<1 == 0 || isnan(y) || ex == 0x7ff)
-		return (x*y)/(x*y);
-	if (ux.i<<1 == 0)
-		return x;
-
-	/* normalize x and y */
-	if (!ex) {
-		for (i = uxi<<12; i>>63 == 0; ex--, i <<= 1);
-		uxi <<= -ex + 1;
-	} else {
-		uxi &= -1ULL >> 12;
-		uxi |= 1ULL << 52;
-	}
-	if (!ey) {
-		for (i = uy.i<<12; i>>63 == 0; ey--, i <<= 1);
-		uy.i <<= -ey + 1;
-	} else {
-		uy.i &= -1ULL >> 12;
-		uy.i |= 1ULL << 52;
-	}
-
-	q = 0;
-	if (ex < ey) {
-		if (ex+1 == ey)
-			goto end;
-		return x;
-	}
-
-	/* x mod y */
-	for (; ex > ey; ex--) {
-		i = uxi - uy.i;
-		if (i >> 63 == 0) {
-			uxi = i;
-			q++;
-		}
-		uxi <<= 1;
-		q <<= 1;
-	}
-	i = uxi - uy.i;
-	if (i >> 63 == 0) {
-		uxi = i;
-		q++;
-	}
-	if (uxi == 0)
-		ex = -60;
-	else
-		for (; uxi>>52 == 0; uxi <<= 1, ex--);
-end:
-	/* scale result and decide between |x| and |x|-|y| */
-	if (ex > 0) {
-		uxi -= 1ULL << 52;
-		uxi |= (uint64_t)ex << 52;
-	} else {
-		uxi >>= -ex + 1;
-	}
-	ux.i = uxi;
-	x = ux.f;
-	if (sy)
-		y = -y;
-	if (ex == ey || (ex+1 == ey && (2*x > y || (2*x == y && q%2)))) {
-		x -= y;
-		q++;
-	}
-	q &= 0x7fffffff;
-	*quo = sx^sy ? -(int)q : (int)q;
-	return sx ? -x : x;
-}
diff --git a/libc/src/musl/math/remquof.c b/libc/src/musl/math/remquof.c
deleted file mode 100644
index 2f41ff7..0000000
--- a/libc/src/musl/math/remquof.c
+++ /dev/null
@@ -1,82 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-float remquof(float x, float y, int *quo)
-{
-	union {float f; uint32_t i;} ux = {x}, uy = {y};
-	int ex = ux.i>>23 & 0xff;
-	int ey = uy.i>>23 & 0xff;
-	int sx = ux.i>>31;
-	int sy = uy.i>>31;
-	uint32_t q;
-	uint32_t i;
-	uint32_t uxi = ux.i;
-
-	*quo = 0;
-	if (uy.i<<1 == 0 || isnan(y) || ex == 0xff)
-		return (x*y)/(x*y);
-	if (ux.i<<1 == 0)
-		return x;
-
-	/* normalize x and y */
-	if (!ex) {
-		for (i = uxi<<9; i>>31 == 0; ex--, i <<= 1);
-		uxi <<= -ex + 1;
-	} else {
-		uxi &= -1U >> 9;
-		uxi |= 1U << 23;
-	}
-	if (!ey) {
-		for (i = uy.i<<9; i>>31 == 0; ey--, i <<= 1);
-		uy.i <<= -ey + 1;
-	} else {
-		uy.i &= -1U >> 9;
-		uy.i |= 1U << 23;
-	}
-
-	q = 0;
-	if (ex < ey) {
-		if (ex+1 == ey)
-			goto end;
-		return x;
-	}
-
-	/* x mod y */
-	for (; ex > ey; ex--) {
-		i = uxi - uy.i;
-		if (i >> 31 == 0) {
-			uxi = i;
-			q++;
-		}
-		uxi <<= 1;
-		q <<= 1;
-	}
-	i = uxi - uy.i;
-	if (i >> 31 == 0) {
-		uxi = i;
-		q++;
-	}
-	if (uxi == 0)
-		ex = -30;
-	else
-		for (; uxi>>23 == 0; uxi <<= 1, ex--);
-end:
-	/* scale result and decide between |x| and |x|-|y| */
-	if (ex > 0) {
-		uxi -= 1U << 23;
-		uxi |= (uint32_t)ex << 23;
-	} else {
-		uxi >>= -ex + 1;
-	}
-	ux.i = uxi;
-	x = ux.f;
-	if (sy)
-		y = -y;
-	if (ex == ey || (ex+1 == ey && (2*x > y || (2*x == y && q%2)))) {
-		x -= y;
-		q++;
-	}
-	q &= 0x7fffffff;
-	*quo = sx^sy ? -(int)q : (int)q;
-	return sx ? -x : x;
-}
diff --git a/libc/src/musl/math/remquol.c b/libc/src/musl/math/remquol.c
deleted file mode 100644
index 9b065c0..0000000
--- a/libc/src/musl/math/remquol.c
+++ /dev/null
@@ -1,124 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double remquol(long double x, long double y, int *quo)
-{
-	return remquo(x, y, quo);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-long double remquol(long double x, long double y, int *quo)
-{
-	union ldshape ux = {x}, uy = {y};
-	int ex = ux.i.se & 0x7fff;
-	int ey = uy.i.se & 0x7fff;
-	int sx = ux.i.se >> 15;
-	int sy = uy.i.se >> 15;
-	uint32_t q;
-
-	*quo = 0;
-	if (y == 0 || isnan(y) || ex == 0x7fff)
-		return (x*y)/(x*y);
-	if (x == 0)
-		return x;
-
-	/* normalize x and y */
-	if (!ex) {
-		ux.i.se = ex;
-		ux.f *= 0x1p120f;
-		ex = ux.i.se - 120;
-	}
-	if (!ey) {
-		uy.i.se = ey;
-		uy.f *= 0x1p120f;
-		ey = uy.i.se - 120;
-	}
-
-	q = 0;
-	if (ex >= ey) {
-		/* x mod y */
-#if LDBL_MANT_DIG == 64
-		uint64_t i, mx, my;
-		mx = ux.i.m;
-		my = uy.i.m;
-		for (; ex > ey; ex--) {
-			i = mx - my;
-			if (mx >= my) {
-				mx = 2*i;
-				q++;
-				q <<= 1;
-			} else if (2*mx < mx) {
-				mx = 2*mx - my;
-				q <<= 1;
-				q++;
-			} else {
-				mx = 2*mx;
-				q <<= 1;
-			}
-		}
-		i = mx - my;
-		if (mx >= my) {
-			mx = i;
-			q++;
-		}
-		if (mx == 0)
-			ex = -120;
-		else
-			for (; mx >> 63 == 0; mx *= 2, ex--);
-		ux.i.m = mx;
-#elif LDBL_MANT_DIG == 113
-		uint64_t hi, lo, xhi, xlo, yhi, ylo;
-		xhi = (ux.i2.hi & -1ULL>>16) | 1ULL<<48;
-		yhi = (uy.i2.hi & -1ULL>>16) | 1ULL<<48;
-		xlo = ux.i2.lo;
-		ylo = ux.i2.lo;
-		for (; ex > ey; ex--) {
-			hi = xhi - yhi;
-			lo = xlo - ylo;
-			if (xlo < ylo)
-				hi -= 1;
-			if (hi >> 63 == 0) {
-				xhi = 2*hi + (lo>>63);
-				xlo = 2*lo;
-				q++;
-			} else {
-				xhi = 2*xhi + (xlo>>63);
-				xlo = 2*xlo;
-			}
-			q <<= 1;
-		}
-		hi = xhi - yhi;
-		lo = xlo - ylo;
-		if (xlo < ylo)
-			hi -= 1;
-		if (hi >> 63 == 0) {
-			xhi = hi;
-			xlo = lo;
-			q++;
-		}
-		if ((xhi|xlo) == 0)
-			ex = -120;
-		else
-			for (; xhi >> 48 == 0; xhi = 2*xhi + (xlo>>63), xlo = 2*xlo, ex--);
-		ux.i2.hi = xhi;
-		ux.i2.lo = xlo;
-#endif
-	}
-
-	/* scale result and decide between |x| and |x|-|y| */
-	if (ex <= 0) {
-		ux.i.se = ex + 120;
-		ux.f *= 0x1p-120f;
-	} else
-		ux.i.se = ex;
-	x = ux.f;
-	if (sy)
-		y = -y;
-	if (ex == ey || (ex+1 == ey && (2*x > y || (2*x == y && q%2)))) {
-		x -= y;
-		q++;
-	}
-	q &= 0x7fffffff;
-	*quo = sx^sy ? -(int)q : (int)q;
-	return sx ? -x : x;
-}
-#endif
diff --git a/libc/src/musl/math/rint.c b/libc/src/musl/math/rint.c
deleted file mode 100644
index fbba390..0000000
--- a/libc/src/musl/math/rint.c
+++ /dev/null
@@ -1,28 +0,0 @@
-#include <float.h>
-#include <math.h>
-#include <stdint.h>
-
-#if FLT_EVAL_METHOD==0 || FLT_EVAL_METHOD==1
-#define EPS DBL_EPSILON
-#elif FLT_EVAL_METHOD==2
-#define EPS LDBL_EPSILON
-#endif
-static const double_t toint = 1/EPS;
-
-double rint(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	int e = u.i>>52 & 0x7ff;
-	int s = u.i>>63;
-	double_t y;
-
-	if (e >= 0x3ff+52)
-		return x;
-	if (s)
-		y = x - toint + toint;
-	else
-		y = x + toint - toint;
-	if (y == 0)
-		return s ? -0.0 : 0;
-	return y;
-}
diff --git a/libc/src/musl/math/rintf.c b/libc/src/musl/math/rintf.c
deleted file mode 100644
index 9047688..0000000
--- a/libc/src/musl/math/rintf.c
+++ /dev/null
@@ -1,30 +0,0 @@
-#include <float.h>
-#include <math.h>
-#include <stdint.h>
-
-#if FLT_EVAL_METHOD==0
-#define EPS FLT_EPSILON
-#elif FLT_EVAL_METHOD==1
-#define EPS DBL_EPSILON
-#elif FLT_EVAL_METHOD==2
-#define EPS LDBL_EPSILON
-#endif
-static const float_t toint = 1/EPS;
-
-float rintf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	int e = u.i>>23 & 0xff;
-	int s = u.i>>31;
-	float_t y;
-
-	if (e >= 0x7f+23)
-		return x;
-	if (s)
-		y = x - toint + toint;
-	else
-		y = x + toint - toint;
-	if (y == 0)
-		return s ? -0.0f : 0.0f;
-	return y;
-}
diff --git a/libc/src/musl/math/rintl.c b/libc/src/musl/math/rintl.c
deleted file mode 100644
index 374327d..0000000
--- a/libc/src/musl/math/rintl.c
+++ /dev/null
@@ -1,29 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double rintl(long double x)
-{
-	return rint(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-
-static const long double toint = 1/LDBL_EPSILON;
-
-long double rintl(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	int s = u.i.se >> 15;
-	long double y;
-
-	if (e >= 0x3fff+LDBL_MANT_DIG-1)
-		return x;
-	if (s)
-		y = x - toint + toint;
-	else
-		y = x + toint - toint;
-	if (y == 0)
-		return 0*x;
-	return y;
-}
-#endif
diff --git a/libc/src/musl/math/scalbln.c b/libc/src/musl/math/scalbln.c
deleted file mode 100644
index e6f3f19..0000000
--- a/libc/src/musl/math/scalbln.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include <limits.h>
-#include <math.h>
-
-double scalbln(double x, long n)
-{
-	if (n > INT_MAX)
-		n = INT_MAX;
-	else if (n < INT_MIN)
-		n = INT_MIN;
-	return scalbn(x, n);
-}
diff --git a/libc/src/musl/math/scalblnf.c b/libc/src/musl/math/scalblnf.c
deleted file mode 100644
index d8e8166..0000000
--- a/libc/src/musl/math/scalblnf.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include <limits.h>
-#include <math.h>
-
-float scalblnf(float x, long n)
-{
-	if (n > INT_MAX)
-		n = INT_MAX;
-	else if (n < INT_MIN)
-		n = INT_MIN;
-	return scalbnf(x, n);
-}
diff --git a/libc/src/musl/math/scalblnl.c b/libc/src/musl/math/scalblnl.c
deleted file mode 100644
index 854c51c..0000000
--- a/libc/src/musl/math/scalblnl.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <limits.h>
-#include <math.h>
-#include <float.h>
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double scalblnl(long double x, long n)
-{
-	return scalbln(x, n);
-}
-#else
-long double scalblnl(long double x, long n)
-{
-	if (n > INT_MAX)
-		n = INT_MAX;
-	else if (n < INT_MIN)
-		n = INT_MIN;
-	return scalbnl(x, n);
-}
-#endif
diff --git a/libc/src/musl/math/scalbn.c b/libc/src/musl/math/scalbn.c
deleted file mode 100644
index 530e07c..0000000
--- a/libc/src/musl/math/scalbn.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-double scalbn(double x, int n)
-{
-	union {double f; uint64_t i;} u;
-	double_t y = x;
-
-	if (n > 1023) {
-		y *= 0x1p1023;
-		n -= 1023;
-		if (n > 1023) {
-			y *= 0x1p1023;
-			n -= 1023;
-			if (n > 1023)
-				n = 1023;
-		}
-	} else if (n < -1022) {
-		y *= 0x1p-1022;
-		n += 1022;
-		if (n < -1022) {
-			y *= 0x1p-1022;
-			n += 1022;
-			if (n < -1022)
-				n = -1022;
-		}
-	}
-	u.i = (uint64_t)(0x3ff+n)<<52;
-	x = y * u.f;
-	return x;
-}
diff --git a/libc/src/musl/math/scalbnf.c b/libc/src/musl/math/scalbnf.c
deleted file mode 100644
index 0b62c3c..0000000
--- a/libc/src/musl/math/scalbnf.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <math.h>
-#include <stdint.h>
-
-float scalbnf(float x, int n)
-{
-	union {float f; uint32_t i;} u;
-	float_t y = x;
-
-	if (n > 127) {
-		y *= 0x1p127f;
-		n -= 127;
-		if (n > 127) {
-			y *= 0x1p127f;
-			n -= 127;
-			if (n > 127)
-				n = 127;
-		}
-	} else if (n < -126) {
-		y *= 0x1p-126f;
-		n += 126;
-		if (n < -126) {
-			y *= 0x1p-126f;
-			n += 126;
-			if (n < -126)
-				n = -126;
-		}
-	}
-	u.i = (uint32_t)(0x7f+n)<<23;
-	x = y * u.f;
-	return x;
-}
diff --git a/libc/src/musl/math/scalbnl.c b/libc/src/musl/math/scalbnl.c
deleted file mode 100644
index 08a4c58..0000000
--- a/libc/src/musl/math/scalbnl.c
+++ /dev/null
@@ -1,36 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double scalbnl(long double x, int n)
-{
-	return scalbn(x, n);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-long double scalbnl(long double x, int n)
-{
-	union ldshape u;
-
-	if (n > 16383) {
-		x *= 0x1p16383L;
-		n -= 16383;
-		if (n > 16383) {
-			x *= 0x1p16383L;
-			n -= 16383;
-			if (n > 16383)
-				n = 16383;
-		}
-	} else if (n < -16382) {
-		x *= 0x1p-16382L;
-		n += 16382;
-		if (n < -16382) {
-			x *= 0x1p-16382L;
-			n += 16382;
-			if (n < -16382)
-				n = -16382;
-		}
-	}
-	u.f = 1.0;
-	u.i.se = 0x3fff + n;
-	return x * u.f;
-}
-#endif
diff --git a/libc/src/musl/math/sqrt.c b/libc/src/musl/math/sqrt.c
deleted file mode 100644
index b277567..0000000
--- a/libc/src/musl/math/sqrt.c
+++ /dev/null
@@ -1,185 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_sqrt.c */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunSoft, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-/* sqrt(x)
- * Return correctly rounded sqrt.
- *           ------------------------------------------
- *           |  Use the hardware sqrt if you have one |
- *           ------------------------------------------
- * Method:
- *   Bit by bit method using integer arithmetic. (Slow, but portable)
- *   1. Normalization
- *      Scale x to y in [1,4) with even powers of 2:
- *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
- *              sqrt(x) = 2^k * sqrt(y)
- *   2. Bit by bit computation
- *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
- *           i                                                   0
- *                                     i+1         2
- *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)
- *           i      i            i                 i
- *
- *      To compute q    from q , one checks whether
- *                  i+1       i
- *
- *                            -(i+1) 2
- *                      (q + 2      ) <= y.                     (2)
- *                        i
- *                                                            -(i+1)
- *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .
- *                             i+1   i             i+1   i
- *
- *      With some algebric manipulation, it is not difficult to see
- *      that (2) is equivalent to
- *                             -(i+1)
- *                      s  +  2       <= y                      (3)
- *                       i                i
- *
- *      The advantage of (3) is that s  and y  can be computed by
- *                                    i      i
- *      the following recurrence formula:
- *          if (3) is false
- *
- *          s     =  s  ,       y    = y   ;                    (4)
- *           i+1      i          i+1    i
- *
- *          otherwise,
- *                         -i                     -(i+1)
- *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)
- *           i+1      i          i+1    i     i
- *
- *      One may easily use induction to prove (4) and (5).
- *      Note. Since the left hand side of (3) contain only i+2 bits,
- *            it does not necessary to do a full (53-bit) comparison
- *            in (3).
- *   3. Final rounding
- *      After generating the 53 bits result, we compute one more bit.
- *      Together with the remainder, we can decide whether the
- *      result is exact, bigger than 1/2ulp, or less than 1/2ulp
- *      (it will never equal to 1/2ulp).
- *      The rounding mode can be detected by checking whether
- *      huge + tiny is equal to huge, and whether huge - tiny is
- *      equal to huge for some floating point number "huge" and "tiny".
- *
- * Special cases:
- *      sqrt(+-0) = +-0         ... exact
- *      sqrt(inf) = inf
- *      sqrt(-ve) = NaN         ... with invalid signal
- *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN
- */
-
-#include "libm.h"
-
-static const double tiny = 1.0e-300;
-
-double sqrt(double x)
-{
-	double z;
-	int32_t sign = (int)0x80000000;
-	int32_t ix0,s0,q,m,t,i;
-	uint32_t r,t1,s1,ix1,q1;
-
-	EXTRACT_WORDS(ix0, ix1, x);
-
-	/* take care of Inf and NaN */
-	if ((ix0&0x7ff00000) == 0x7ff00000) {
-		return x*x + x;  /* sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN */
-	}
-	/* take care of zero */
-	if (ix0 <= 0) {
-		if (((ix0&~sign)|ix1) == 0)
-			return x;  /* sqrt(+-0) = +-0 */
-		if (ix0 < 0)
-			return (x-x)/(x-x);  /* sqrt(-ve) = sNaN */
-	}
-	/* normalize x */
-	m = ix0>>20;
-	if (m == 0) {  /* subnormal x */
-		while (ix0 == 0) {
-			m -= 21;
-			ix0 |= (ix1>>11);
-			ix1 <<= 21;
-		}
-		for (i=0; (ix0&0x00100000) == 0; i++)
-			ix0<<=1;
-		m -= i - 1;
-		ix0 |= ix1>>(32-i);
-		ix1 <<= i;
-	}
-	m -= 1023;    /* unbias exponent */
-	ix0 = (ix0&0x000fffff)|0x00100000;
-	if (m & 1) {  /* odd m, double x to make it even */
-		ix0 += ix0 + ((ix1&sign)>>31);
-		ix1 += ix1;
-	}
-	m >>= 1;      /* m = [m/2] */
-
-	/* generate sqrt(x) bit by bit */
-	ix0 += ix0 + ((ix1&sign)>>31);
-	ix1 += ix1;
-	q = q1 = s0 = s1 = 0;  /* [q,q1] = sqrt(x) */
-	r = 0x00200000;        /* r = moving bit from right to left */
-
-	while (r != 0) {
-		t = s0 + r;
-		if (t <= ix0) {
-			s0   = t + r;
-			ix0 -= t;
-			q   += r;
-		}
-		ix0 += ix0 + ((ix1&sign)>>31);
-		ix1 += ix1;
-		r >>= 1;
-	}
-
-	r = sign;
-	while (r != 0) {
-		t1 = s1 + r;
-		t  = s0;
-		if (t < ix0 || (t == ix0 && t1 <= ix1)) {
-			s1 = t1 + r;
-			if ((t1&sign) == sign && (s1&sign) == 0)
-				s0++;
-			ix0 -= t;
-			if (ix1 < t1)
-				ix0--;
-			ix1 -= t1;
-			q1 += r;
-		}
-		ix0 += ix0 + ((ix1&sign)>>31);
-		ix1 += ix1;
-		r >>= 1;
-	}
-
-	/* use floating add to find out rounding direction */
-	if ((ix0|ix1) != 0) {
-		z = 1.0 - tiny; /* raise inexact flag */
-		if (z >= 1.0) {
-			z = 1.0 + tiny;
-			if (q1 == (uint32_t)0xffffffff) {
-				q1 = 0;
-				q++;
-			} else if (z > 1.0) {
-				if (q1 == (uint32_t)0xfffffffe)
-					q++;
-				q1 += 2;
-			} else
-				q1 += q1 & 1;
-		}
-	}
-	ix0 = (q>>1) + 0x3fe00000;
-	ix1 = q1>>1;
-	if (q&1)
-		ix1 |= sign;
-	ix0 += m << 20;
-	INSERT_WORDS(z, ix0, ix1);
-	return z;
-}
diff --git a/libc/src/musl/math/sqrtf.c b/libc/src/musl/math/sqrtf.c
deleted file mode 100644
index 28cb4ad..0000000
--- a/libc/src/musl/math/sqrtf.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/* origin: FreeBSD /usr/src/lib/msun/src/e_sqrtf.c */
-/*
- * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
- */
-/*
- * ====================================================
- * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
- *
- * Developed at SunPro, a Sun Microsystems, Inc. business.
- * Permission to use, copy, modify, and distribute this
- * software is freely granted, provided that this notice
- * is preserved.
- * ====================================================
- */
-
-#include "libm.h"
-
-static const float tiny = 1.0e-30;
-
-float sqrtf(float x)
-{
-	float z;
-	int32_t sign = (int)0x80000000;
-	int32_t ix,s,q,m,t,i;
-	uint32_t r;
-
-	GET_FLOAT_WORD(ix, x);
-
-	/* take care of Inf and NaN */
-	if ((ix&0x7f800000) == 0x7f800000)
-		return x*x + x; /* sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN */
-
-	/* take care of zero */
-	if (ix <= 0) {
-		if ((ix&~sign) == 0)
-			return x;  /* sqrt(+-0) = +-0 */
-		if (ix < 0)
-			return (x-x)/(x-x);  /* sqrt(-ve) = sNaN */
-	}
-	/* normalize x */
-	m = ix>>23;
-	if (m == 0) {  /* subnormal x */
-		for (i = 0; (ix&0x00800000) == 0; i++)
-			ix<<=1;
-		m -= i - 1;
-	}
-	m -= 127;  /* unbias exponent */
-	ix = (ix&0x007fffff)|0x00800000;
-	if (m&1)  /* odd m, double x to make it even */
-		ix += ix;
-	m >>= 1;  /* m = [m/2] */
-
-	/* generate sqrt(x) bit by bit */
-	ix += ix;
-	q = s = 0;       /* q = sqrt(x) */
-	r = 0x01000000;  /* r = moving bit from right to left */
-
-	while (r != 0) {
-		t = s + r;
-		if (t <= ix) {
-			s = t+r;
-			ix -= t;
-			q += r;
-		}
-		ix += ix;
-		r >>= 1;
-	}
-
-	/* use floating add to find out rounding direction */
-	if (ix != 0) {
-		z = 1.0f - tiny; /* raise inexact flag */
-		if (z >= 1.0f) {
-			z = 1.0f + tiny;
-			if (z > 1.0f)
-				q += 2;
-			else
-				q += q & 1;
-		}
-	}
-	ix = (q>>1) + 0x3f000000;
-	ix += m << 23;
-	SET_FLOAT_WORD(z, ix);
-	return z;
-}
diff --git a/libc/src/musl/math/sqrtl.c b/libc/src/musl/math/sqrtl.c
deleted file mode 100644
index 83a8f80..0000000
--- a/libc/src/musl/math/sqrtl.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <math.h>
-
-long double sqrtl(long double x)
-{
-	/* FIXME: implement in C, this is for LDBL_MANT_DIG == 64 only */
-	return sqrt(x);
-}
diff --git a/libc/src/musl/math/trunc.c b/libc/src/musl/math/trunc.c
deleted file mode 100644
index d13711b..0000000
--- a/libc/src/musl/math/trunc.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "libm.h"
-
-double trunc(double x)
-{
-	union {double f; uint64_t i;} u = {x};
-	int e = (int)(u.i >> 52 & 0x7ff) - 0x3ff + 12;
-	uint64_t m;
-
-	if (e >= 52 + 12)
-		return x;
-	if (e < 12)
-		e = 1;
-	m = -1ULL >> e;
-	if ((u.i & m) == 0)
-		return x;
-	FORCE_EVAL(x + 0x1p120f);
-	u.i &= ~m;
-	return u.f;
-}
diff --git a/libc/src/musl/math/truncf.c b/libc/src/musl/math/truncf.c
deleted file mode 100644
index 1a7d03c..0000000
--- a/libc/src/musl/math/truncf.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "libm.h"
-
-float truncf(float x)
-{
-	union {float f; uint32_t i;} u = {x};
-	int e = (int)(u.i >> 23 & 0xff) - 0x7f + 9;
-	uint32_t m;
-
-	if (e >= 23 + 9)
-		return x;
-	if (e < 9)
-		e = 1;
-	m = -1U >> e;
-	if ((u.i & m) == 0)
-		return x;
-	FORCE_EVAL(x + 0x1p120f);
-	u.i &= ~m;
-	return u.f;
-}
diff --git a/libc/src/musl/math/truncl.c b/libc/src/musl/math/truncl.c
deleted file mode 100644
index f07b193..0000000
--- a/libc/src/musl/math/truncl.c
+++ /dev/null
@@ -1,34 +0,0 @@
-#include "libm.h"
-
-#if LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024
-long double truncl(long double x)
-{
-	return trunc(x);
-}
-#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
-
-static const long double toint = 1/LDBL_EPSILON;
-
-long double truncl(long double x)
-{
-	union ldshape u = {x};
-	int e = u.i.se & 0x7fff;
-	int s = u.i.se >> 15;
-	long double y;
-
-	if (e >= 0x3fff+LDBL_MANT_DIG-1)
-		return x;
-	if (e <= 0x3fff-1) {
-		FORCE_EVAL(x + 0x1p120f);
-		return x*0;
-	}
-	/* y = int(|x|) - |x|, where int(|x|) is an integer neighbor of |x| */
-	if (s)
-		x = -x;
-	y = x + toint - toint - x;
-	if (y > 0)
-		y -= 1;
-	x += y;
-	return s ? -x : x;
-}
-#endif
diff --git a/libuser/build.sh b/libuser/build.sh
index 00d847f..f7eafed 100644
--- a/libuser/build.sh
+++ b/libuser/build.sh
@@ -13,10 +13,14 @@ with OBJ					"obj"
 with INC					"inc"
 
 with ARTIFACT_NAME			"libghostuser.a"
-ARTIFACT_LOCAL="$ARTIFACT_NAME"
-ARTIFACT_TARGET="$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME"
+with ARTIFACT_LOCAL			"$ARTIFACT_NAME"
+with ARTIFACT_TARGET		"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME"
+with ARTIFACT_NAME_SHARED	"libghostuser.so"
+with ARTIFACT_LOCAL_SHARED	"$ARTIFACT_NAME_SHARED"
+with ARTIFACT_TARGET_SHARED	"$SYSROOT_SYSTEM_LIB/$ARTIFACT_NAME_SHARED"
 
 with CFLAGS					"-std=c++11 -I$SYSROOT_SYSTEM_INCLUDE/freetype2 -I$INC -I$SRC" # TODO move headers and remove SRC
+with LDFLAGS				"-shared"
 
 
 echo "target: $TARGET"
@@ -26,6 +30,7 @@ requireTool changes
 target_clean() {
 	echo "cleaning:"
 	rm $ARTIFACT_LOCAL
+	rm $ARTIFACT_LOCAL_SHARED
 	cleanDirectory $OBJ
 	changes --clear
 }
@@ -60,19 +65,21 @@ target_compile() {
 target_archive() {
 	echo "archiving:"
 	$CROSS_AR -r $ARTIFACT_LOCAL $OBJ/*.o
+	$CROSS_CC $LDFLAGS -o $ARTIFACT_LOCAL_SHARED $OBJ/*.o
 }
 	
 target_clean_target() {
 	
 	echo "removing $ARTIFACT_TARGET"
 	rm $ARTIFACT_TARGET 2&> /dev/null
+	echo "removing $ARTIFACT_TARGET_SHARED"
+	rm $ARTIFACT_TARGET_SHARED 2&> /dev/null
 }
 
 target_install_headers() {
 
 	echo "installing headers"
 	cp -r $INC/* $SYSROOT_SYSTEM_INCLUDE/
-
 	
 }
 
@@ -81,11 +88,12 @@ target_install() {
 	target_clean_target
 	target_install_headers
 	
-	echo "installing artifact"
+	echo "installing artifacts"
 	cp $ARTIFACT_LOCAL $ARTIFACT_TARGET
+	cp $ARTIFACT_LOCAL_SHARED $ARTIFACT_TARGET_SHARED
 	
 	# c'mon
-	chmod -R 777 $SYSROOT
+	sudo chmod -R 777 $SYSROOT
 }
 
 
